# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-12-14T13:35:17\n"
"PO-Revision-Date: 2009-06-09 03:50+0900\n"
"Last-Translator: Shinobu NOGAMI <s-nogami@sourceforge.jp>\n"
"Language-Team: none\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "So you&#39;re keen to get started writing your first bean? Or perhaps you&#39;re skeptical, wondering what kinds of hoops the CDI specification will make you jump through! The good news is that you&#39;ve probably already written and used hundreds, perhaps thousands of beans. CDI just makes it easier to actually use them to build an application!"
msgstr "あなたは、すでに最初の Web Bean を書き始めることに夢中ですか。あるいは、たぶん Web Beans 仕様によって、どのような種類のフープを跳ぶことができるのかを不思議に思って疑い深くなっているのかもしれません。朗報なことは、すでにあなたはおそらく数百、もしかすると数千の Web Beans を書いて使用しているかもしれないということです。あなたは最初の書いた Web Bean を思い出すことさえできないかもしれません。"

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Web Bean とは何か?"

#. Tag: para
#, no-c-format
msgid "A bean is exactly what you think it is. Only now, it has a true identity in the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Prior to Java EE 6, there was no clear definition of the term &#34;bean&#34; in the Java EE platform. Of course, we&#39;ve been calling Java classes used in web and enterprise applications &#34;beans&#34; for years. There were even a couple of different kinds of things called &#34;beans&#34; in EE specifications, including EJB beans and JSF managed beans. Meanwhile, other third-party frameworks such as Spring and Seam introduced their own ideas of what it meant to be a &#34;bean&#34;. What we&#39;ve been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java EE 6 finally lays down that common definition in the Managed Beans specification. Managed Beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks and interceptors. Companion specifications, such as EJB and CDI, build on this basic model. But, <emphasis>at last</emphasis>, there&#39;s a uniform concept of a bean and a lightweight component model that&#39;s aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid "With very few exceptions, almost every concrete Java class that has a constructor with no parameters (or a constructor designated with the annotation <literal>@Inject</literal>) is a bean. This includes every JavaBean and every EJB session bean. If you&#39;ve already got some JavaBeans or session beans lying around, they&#39;re already beans—you won&#39;t need any additional special metadata. There&#39;s just little one thing you need to do before you can start injecting them into stuff: you need to put them in an archive (a jar, or a Java EE module such as a war or EJB jar) that contains a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The JavaBeans and EJBs you&#39;ve been writing every day, up until now, have not been able to take advantage of the new services defined by the CDI specification. But you&#39;ll be able to use every one of them with CDI—allowing the container to create and destroy instances of your beans and associate them with a designated context, injecting them into other beans, using them in EL expressions, specializing them with qualifier annotations, even adding interceptors and decorators to them—without modifying your existing code. At most, you&#39;ll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let&#39;s see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Suppose that we have two existing Java classes that we&#39;ve been using for years in various applications. The first class parses a string into a list of sentences:"
msgstr "様々なアプリケーションで何年間も使っている２つの既存の Java クラスがあると仮定します。１つ目のクラスは、文のリストへ文字列に構文解析します:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class SentenceParser {\n"
"   public List&#60;String&#62; parse(String text) { ... }\n"
"}"
msgstr ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "The second existing class is a stateless session bean front-end for an external system that is able to translate sentences from one language to another:"
msgstr "２つ目の現存するクラスは、１つの言語からもう１つの言語への文を翻訳することができる外部システムのフロントエンドとなるステートレスセッション Bean です:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"   public String translate(String sentence) { ... }\n"
"}"
msgstr ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "ここで <literal>Translator</literal> はローカルインターフェースです:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Local\n"
"public interface Translator {\n"
"   public String translate(String sentence);\n"
"}"
msgstr ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, we don&#39;t have a class that translates whole text documents. So let&#39;s write a bean for this job:"
msgstr "運悪く、すべてのテキストドキュメントを翻訳する既存のクラスはありません。そこでこの仕事をする Web Bean を書きましょう:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class TextTranslator {\n"
"   private SentenceParser sentenceParser;\n"
"   private Translator sentenceTranslator;\n"
"    \n"
"   @Inject\n"
"   TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"      this.sentenceParser = sentenceParser;\n"
"      this.sentenceTranslator = sentenceTranslator;\n"
"   }\n"
"    \n"
"   public String translate(String text) {\n"
"      StringBuilder sb = new StringBuilder();\n"
"      for (String sentence: sentenceParser.parse(text)) {\n"
"          sb.append(sentenceTranslator.translate(sentence));\n"
"      }\n"
"      return sb.toString();\n"
"   }\n"
"}"
msgstr ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "But wait! <literal>TextTranslator</literal> does not have a constructor with no parameters! Is it still a bean? If you remember, a class that does not have a constructor with no parameters can still be a bean if it has a constructor annotated <literal>@Inject</literal>."
msgstr "しかし待ってください: <literal>TextTranslator</literal> はパラメータなしのコンストラクタがありません。それはまだ Web Bean ですか。まあ、<literal>@Initializer</literal> アノテーションを付けたコンストラクタがあれば、パラメータなしのコンストラクタを持たないクラスもまだ Web Bean であることができます。"

#. Tag: para
#, fuzzy, no-c-format
msgid "As you&#39;ve guessed, the <literal>@Inject</literal> annotation has something to do with dependency injection! <literal>@Inject</literal> may be applied to a constructor or method of a bean, and tells the container to call that constructor or method when instantiating the bean. The container will inject other beans into the parameters of the constructor or method."
msgstr "あなたが推測しているように、 <literal>@Initializer</literal> ノテーションは依存性注入と関係があります。<literal>@Initializer</literal> は、Web Bean のコンストラクタあるいはメソッドに適用することができ、Web Bean をインスタンス化するときに Web Bean マネージャにそのコンストラクタあるいはメソッドを呼ぶ出すように伝えます。Web Beanマネージャは、コンストラクタあるいはメソッドのパラメータに他の Web Beans を注入します。"

#. Tag: para
#, no-c-format
msgid "We may obtain an instance of <literal>TextTranslator</literal> by injecting it into a constructor, method or field of a bean, or a field or method of a Java EE component class such as a servlet. The container chooses the object to be injected based on the type of the injection point, not the name of the field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Let&#39;s create a UI controller bean that uses field injection to obtain an instance of the <literal>TextTranslator</literal>, translating the text entered by a user:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Named @RequestScoped\n"
"public class TranslateController {\n"
"   @Inject TextTranslator textTranslator;\n"
"\n"
"   private String inputText;\n"
"   private String translation;\n"
"\n"
"   // JSF action method, perhaps\n"
"   public void translate() {\n"
"      translation = textTranslator.translate(inputText); \n"
"   }\n"
"\n"
"   public String getInputText() {\n"
"      return inputText;\n"
"   }\n"
"\n"
"   public void setInputText(String text) {\n"
"      this.inputText = text;\n"
"   }\n"
"\n"
"   public String getTranslation() {\n"
"      return translation;\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "ここで <literal>Translator</literal> はローカルインターフェースです:"

#. Tag: para
#, no-c-format
msgid "Notice the controller bean is request-scoped and named. Since this combination is so common in web applications, there&#39;s a built-in annotation for it in CDI that we could have used as a shorthand. When the (stereotype) annotation <literal>@Model</literal> is declared on a class, it creates a request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Alternatively, we may obtain an instance of <literal>TextTranslator</literal> programmatically from an injected instance of <literal>Instance</literal>, parameterized with the bean type:"
msgstr "Web Bean、サーブレットあるいは EJB へ注入することによって <literal>TextTranslator</literal> のインスタンスを取得することができます:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject Instance&#60;TextTranslator&#62; textTranslatorInstance;\n"
"...\n"
"public void translate() {\n"
"   textTranslatorInstance.get().translate(inputText);\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Notice that it isn&#39;t necessary to create a getter or setter method to inject one bean into another. CDI can access an injected field directly (even if it&#39;s private!), which sometimes helps eliminate some wasteful code. The name of the field is arbitrary. It&#39;s the field&#39;s type that determines what is injected."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "At system initialization time, the container must validate that exactly one bean exists which satisfies each injection point. In our example, if no implementation of <literal>Translator</literal> is available—if the <literal>SentenceTranslator</literal> EJB was not deployed—the container would inform us of an <emphasis>unsatisfied dependency</emphasis>. If more than one implementation of <literal>Translator</literal> were available, the container would inform us of the <emphasis>ambiguous dependency</emphasis>."
msgstr "システムの初期化時に、Web Bean マネージャはそれぞれのインジェクションポイントの条件を満たすまさに１つの Web Bean が存在することを検証しなければなりません。サンプルで、もし利用可能な <literal>Translator</literal> の実装がなければ&#151;、あるいは <literal>SentenceTranslator</literal> EJB がデプロイされていなければ&#151;、Web Bean マネージャーは、<literal>UnsatisfiedDependencyException</literal> をスローします。もし１つ以上の <literal>Translator</literal> の実装が利用可能であれば、Web Beanマネージャは、<literal>AmbiguousDependencyException</literal> をスローします。"

#. Tag: para
#, no-c-format
msgid "Before we get too deep in the details, let&#39;s pause and examine a bean&#39;s anatomy. What aspects of the bean are significant, and what gives it its identity? Instead of just giving examples of beans, we&#39;re going to define what <emphasis>makes</emphasis> something a bean."
msgstr ""

#~ msgid "Getting started with Web Beans"
#~ msgstr "Web Beans を始めよう"

#~ msgid "Your first Web Bean"
#~ msgstr "初めての Web Bean"

#~ msgid "With certain, very special exceptions, every Java class with a constructor that accepts no parameters is a Web Bean. That includes every JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. Sure, the JavaBeans and EJBs you've been writing every day have not been able to take advantage of the new services defined by the Web Beans specification, but you'll be able to use every one of them as Web Beans &#151; injecting them into other Web Beans, configuring them via the Web Beans XML configuration facility, even adding interceptors and decorators to them &#151; without touching your existing code."
#~ msgstr "ある特定のとても特別な例外を除いて、パラメータなしのコンストラクタを持つすべての Java クラスは、Web Bean です。それはすべての JavaBean を含みます。さらに、すべての EJB 3 仕様のセッション Bean も、Web Bean です。確かに、毎日書いている JavaBean と EJB は、Web Beans 仕様によって定義された新しいサービスを利用することができていません。しかし、それらすべての各々は、&#151; Web Beans の XML 構成機能によって構成し、そしてそれらにインタセプタとデコレータを加えることによって &#151;、現存するコードに触れることなく、Web Beans として使用することができるでしょう。"

#~ msgid "Alternatively, we may obtain an instance by directly calling a method of the Web Bean manager:"
#~ msgstr "もう１つの方法として、Web Bean マネージャのメソッドを直接に呼ぶことによってインスタンスを取得することもできます:"

#~ msgid "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"
#~ msgstr "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"

#~ msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
#~ msgstr "それでは、Web Bean とは、<emphasis> 一体</emphasis> 何か。"

#~ msgid "A Web Bean is an application class that contains business logic. A Web Bean may be called directly from Java code, or it may be invoked via Unified EL. A Web Bean may access transactional resources. Dependencies between Web Beans are managed automatically by the Web Bean manager. Most Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean manager."
#~ msgstr "Web Bean は、ビジネスロジックを含むアプリケーションクラスです。Web Bean は、直接 Java コードから呼び出すこともでき、あるいはユニファイド EL から呼び出すこともできます。Web Bean は、トランザクションのリソースにアクセスすることもできます。Web Beans 間での依存関係は、Web Bean マネージャによって自動的に管理されます。 ほとんどのWeb Beansは <emphasis>ステートフル</emphasis> で <emphasis>コンテキスト依存</emphasis> です。Web Bean のライフサイクルは Web Bean マネージャによっていつも管理されます。"

#~ msgid "Let's back up a second. What does it really mean to be \"contextual\"? Since Web Beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a Web Bean see the Web Bean in different states. The client-visible state depends upon which instance of the Web Bean the client has a reference to."
#~ msgstr "少しの間ゆっくり考えてみましょう。「コンテキスト依存である」ということは、本当に何を意味するのでしょうか。Web Beans はステートフルですので、 <emphasis>どの</emphasis> Bean インスタンスを持っているかが重要です。ステートレスなコンポーネントモデル(例えば、ステートレスセッション bean)あるいはシングルトンコンポーネントモデル(例えばサーブレット、あるいはシングルトン bean)と違って、Web Bean の異なるクライアントは、異なる状態で Web Bean を参照します。クライアントに見える状態は、Web Bean のどちらのインスタンスへのリファレンスをクライアントが持っているかによります。"

#~ msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
#~ msgstr "しかし、しかしステートフルなセッション bean とは <emphasis>違って</emphasis>、クライアントは、ステートレスあるいはシングルトンモデルと同じように、明示的にインスタンスの生成と破棄を行ってインスタンスのライフサイクルを制御はしません。その代わりに、Web Bean の <emphasis>スコープ</emphasis> は以下で決定されます:"

#~ msgid "the lifecycle of each instance of the Web Bean and"
#~ msgstr "Web Bean のそれぞれのインスタンスのライフサイクル"

#~ msgid "which clients share a reference to a particular instance of the Web Bean."
#~ msgstr "Web Bean のある特定のリファレンスをどのクライアントが共用しているか"

#~ msgid "For a given thread in a Web Beans application, there may be an <emphasis>active context</emphasis> associated with the scope of the Web Bean. This context may be unique to the thread (for example, if the Web Bean is request scoped), or it may be shared with certain other threads (for example, if the Web Bean is session scoped) or even all other threads (if it is application scoped)."
#~ msgstr "Web Beans アプリケーションに与えられたスレッドには、Web Bean のスコープに関連付けられた <emphasis>アクティブコンテキスト</emphasis> があります。このコンテキストは、そのスレッドに固有かもしれません(例えば、Web Bean がリクエストスコープの場合)。あるいは、それはその他のスレッド間で共用されるかもしれません(例えば、Web Bean がセッションスコープの場合)。あるいは、それはすべてのスレッドで共用されるかもしれません(アプリケーションスコープの場合)。"

#~ msgid "Clients (for example, other Web Beans) executing in the same context will see the same instance of the Web Bean. But clients in a different context will see a different instance."
#~ msgstr "同じコンテキストで実行しているクライアント(例えば、他の Web Beans)は、同じインスタンスの Web Bean を参照するでしょう。しかし、異なるコンテキストのクライアントは、異なるインスタンスを参照します。"

#~ msgid "One great advantage of the contextual model is that it allows stateful Web Beans to be treated like services! The client need not concern itself with managing the lifecycle of the Web Bean it is using, <emphasis>nor does it even need to know what that lifecyle is.</emphasis> Web Beans interact by passing messages, and the Web Bean implementations define the lifecycle of their own state. The Web Beans are loosely coupled because:"
#~ msgstr "コンテキスト依存モデルのすばらしい利点の１つには、ステートフルな Web Beans をサービスのように取り扱うことを可能にすることがあります。クライアントは、使用している Web Bean のライフサイクルの管理に関与する必要はありません。 <emphasis>またさらにライフサイクルが何であるかも知っている必要はありません。</emphasis> Web Beansは、メッセージを送信することによって相互に作用し、 Web Bean の実装が自分自身の状態のライフサイクルを定義します。Web Beans が疎結合なのは以下の理由からです:"

#~ msgid "they interact via well-defined public APIs"
#~ msgstr "明確に定義されたパブリックなAPI経由で相互に作用する"

#~ msgid "their lifecycles are completely decoupled"
#~ msgstr "ライフサイクルは完全に切り離されている"

#~ msgid "We can replace one Web Bean with a different Web Bean that implements the same API and has a different lifecycle (a different scope) without affecting the other Web Bean implementation. In fact, Web Beans defines a sophisticated facility for overriding Web Bean implementations at deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "１つの Web Bean は、その他の Web Bean の実装には影響せずに、同じAPIを実装した異なるライフサイクル(異なるスコープ)を持つ別の Web Bean に置き換えることができます。<xref linkend=\"deploymenttypes\"/> で説明するように、実際 Web Beansは、デプロイメント時に Web Bean の実装をオーバーライドするための洗練された機構を定義します。"

#~ msgid "Note that not all clients of a Web Bean are Web Beans. Other objects such as Servlets or Message-Driven Beans &#151; which are by nature not injectable, contextual objects &#151; may also obtain references to Web Beans by injection."
#~ msgstr "すべての Web Bean のクライアントが必ずしも Web Beans ではないことに注意してください。サーブレットまたはメッセージ駆動 Bean といった他のオブジェクト&#151;生まれつき注入可能でなく、コンテキスト依存ではいオブジェクト&#151; が注入によって Web Beans へのリファレンスを取得することもあります。"

#~ msgid "Enough hand-waving. More formally, according to the spec:"
#~ msgstr "より正式には、仕様は次の通りです:"

#~ msgid "A Web Bean comprises:"
#~ msgstr "Web Bean は以下の要素から構成されます:"

#~ msgid "A (nonempty) set of API types"
#~ msgstr "(空ではない) API タイプのセット"

#~ msgid "A (nonempty) set of binding annotation types"
#~ msgstr "(空ではない) バインディングアノテーションタイプのセット"

#~ msgid "A scope"
#~ msgstr "スコープ"

#~ msgid "A deployment type"
#~ msgstr "デプロイメントタイプ"

#~ msgid "Optionally, a Web Bean name"
#~ msgstr "(オプションの) Web Bean 名"

#~ msgid "A set of interceptor binding types"
#~ msgstr "インタセプタのバインディングタイプのセット"

#~ msgid "A Web Bean implementation"
#~ msgstr "Web Bean インプリメンテーション"

#~ msgid "Let's see what some of these terms mean, to the Web Bean developer."
#~ msgstr "Web Bean 開発者にとって、これらの用語が何を意味するのか確認しましょう。"

#~ msgid "API types, binding types and dependency injection"
#~ msgstr "API タイプとバインディングタイプと依存性注入"

#~ msgid "Web Beans usually acquire references to other Web Beans via dependency injection. Any injected attribute specifies a \"contract\" that must be satisfied by the Web Bean to be injected. The contract is:"
#~ msgstr "Web Beans は、通常は依存性注入によって他の Web Beans への参照を獲得します。注入されるどの属性も、注入される Web Bean が条件を満たさなければならない「契約」を指定します。契約は以下の通りです:"

#~ msgid "an API type, together with"
#~ msgstr "API タイプ"

#~ msgid "a set of binding types."
#~ msgstr "バインディングタイプのセット"

#~ msgid "An API is a user-defined class or interface. (If the Web Bean is an EJB session bean, the API type is the <literal>@Local</literal> interface or bean-class local view). A binding type represents some client-visible semantic that is satisfied by some implementations of the API and not by others."
#~ msgstr "API は、ユーザ定義のクラスあるいはインタフェースです。(もし Web Bean が EJB セッション Bean ならば、API タイプは <literal>@Local</literal>  インターフェースか bean クラスのローカルビューです)。バインディングタイプは、API のある実装によっては満たされ他のものでは満足されない、クライアントに見えるセマンティックを表します。"

#~ msgid "Binding types are represented by user-defined annotations that are themselves annotated <literal>@BindingType</literal>. For example, the following injection point has API type <literal>PaymentProcessor</literal> and binding type <literal>@CreditCard</literal>:"
#~ msgstr "バインディングタイプは、それ自身が <literal>@BindingType</literal> アノテーションを付与されたユーザ定義のアノテーションによって表されます。例えば、以下のインジェクションポイントは、API タイプ <literal>PaymentProcessor</literal> とバインディングタイプ <literal>@CreditCard</literal> を持っています:"

#~ msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
#~ msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#~ msgid "If no binding type is explicitly specified at an injection point, the default binding type <literal>@Current</literal> is assumed."
#~ msgstr "もしどのバインディングタイプもインジェクションポイントで明示的に指定されなければ、デフォルトのバインディングタイプ <literal>@Current</literal> が想定されます。"

#~ msgid "For each injection point, the Web Bean manager searches for a Web Bean which satisfies the contract (implements the API, and has all the binding types), and injects that Web Bean."
#~ msgstr "各々のインジェクションポイントに対して、Web Bean マネージャは、契約(API の実装、すべてのバインディングタイプの所持)の条件を満たす Web Bean を探し、その Web Bean を注入します。"

#~ msgid "The following Web Bean has the binding type <literal>@CreditCard</literal> and implements the API type <literal>PaymentProcessor</literal>. It could therefore be injected to the example injection point:"
#~ msgstr "以下の Web Bean は、バインディングタイプ <literal>@CreditCard</literal> を持ち、API タイプ <literal>PaymentProcessor</literal> を実装しています。それゆえ、サンプルのインジェクションポイントに注入することができます:"

#~ msgid ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"

#~ msgid "If a Web Bean does not explicitly specify a set of binding types, it has exactly one binding type: the default binding type <literal>@Current</literal>."
#~ msgstr "もし Web Bean が明示的にバインディングタイプのセットを指定しなければ、それは１つのバインディングタイプ : デフォルトのバインディングタイプ<literal>@Current</literal> を持つことになります。"

#~ msgid "Web Beans defines a sophisticated but intuitive <emphasis>resolution algorithm</emphasis> that helps the container decide what to do if there is more than one Web Bean that satisfies a particular contract. We'll get into the details in <xref linkend=\"injection\"/>."
#~ msgstr "Web Beans は、もし特定の契約と満たす１つ以上の Web Bean があったときに、コンテナが何をすべきかを決定するのを助ける洗練されたしかも直観的な <emphasis>解決アルゴリズム</emphasis> を定義します。その詳細は <xref linkend=\"injection\"/> で説明します。"

#~ msgid "Deployment types"
#~ msgstr "デプロイメントタイプ"

#~ msgid "<emphasis>Deployment types</emphasis> let us classify our Web Beans by deployment scenario. A deployment type is an annotation that represents a particular deployment scenario, for example <literal>@Mock</literal>, <literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We apply the annotation to Web Beans which should be deployed in that scenario. A deployment type allows a whole set of Web Beans to be conditionally deployed, with a just single line of configuration."
#~ msgstr "<emphasis>デプロイメントタイプ</emphasis> は、デプロイメントシナリオによって Web Beans を分類させます。デプロイメントタイプは、特定のデプロイメントシナリオを表すアノテーション、例えば <literal>@Mock</literal> や <literal>@Staging</literal>、<literal>@AustralianTaxLaw</literal> です。そのシナリオでデプロイされるべき Web Beans にアノテーションを適用します。デプロイメントタイプは、単一の構成で１セットの Web Beans すべてを条件つきでデプロイすることを可能にします。"

#~ msgid "Many Web Beans just use the default deployment type <literal>@Production</literal>, in which case no deployment type need be explicitly specified. All three Web Bean in our example have the deployment type <literal>@Production</literal>."
#~ msgstr "多くの Web Beans は、どのデプロイメントタイプも明示的に指定されていない場合、単にデフォルトのデプロイメントタイプ <literal>@Production</literal> を使用します。サンプルで使用する３つの Web Bean すべては、デプロイメントタイプ <literal>@Production</literal> を持っています。"

#~ msgid "In a testing environment, we might want to replace the <literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
#~ msgstr "テスト環境では、<literal>SentenceTranslator</literal> Web Bean を「モックオブジェクト」で置き換えたいでしょう:"

#~ msgid ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"

#~ msgid "We would enable the deployment type <literal>@Mock</literal> in our testing environment, to indicate that <literal>MockSentenceTranslator</literal> and any other Web Bean annotated <literal>@Mock</literal> should be used."
#~ msgstr "<literal>MockSentenceTranslator</literal> と <literal>@Mock</literal> アノテーションが付与されたその他の Web Bean を使用することを指定するために、テスト環境ではデプロイメントタイプ <literal>@Mock</literal> を有効にします。"

#~ msgid "We'll talk more about this unique and powerful feature in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "この独特で強力な機能については <xref linkend=\"deploymenttypes\"/> で説明します。"

#~ msgid "Scope"
#~ msgstr "スコープ"

#~ msgid "The <emphasis>scope</emphasis> defines the lifecycle and visibility of instances of the Web Bean. The Web Beans context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built-in to the specification, and provided by the Web Bean manager. A scope is represented by an annotation type."
#~ msgstr "<emphasis>スコープ</emphasis> は Web Bean のインスタンスのライフサイクルと可視性を定義します。Web Beans のコンテキストモデルは拡張可能で、任意のスコープを収容できます。しかし、非常に重要なスコープは仕様に組み込まれ、Web Bean マネージャー によって提供されています。スコープはアノテーションタイプによって表されます。"

#~ msgid "For example, any web application may have <emphasis>session scoped</emphasis> Web Beans:"
#~ msgstr "例えば、どんな Web アプリケーションも <emphasis>セッションスコープ</emphasis> の Web Beansを持っています:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "An instance of a session scoped Web Bean is bound to a user session and is shared by all requests that execute in the context of that session."
#~ msgstr "セッションスコープの Web Bean のインスタンスはユーザセッションにバインドされて、そのセッションのコンテキストで実行されるすべてのリクエストによって共有されます。"

#~ msgid "By default, Web Beans belong to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope are pure dependent objects of the object into which they are injected, and their lifecycle is bound to the lifecycle of that object."
#~ msgstr "デフォルトでは、Web Beans は <emphasis>依存擬似スコープ</emphasis> と呼ばれる特別なスコープに属します。このスコープをもつ Web Beans は、注入したオブジェクトに純粋に依存するオブジェクトで、ライフサイクルは注入したオブジェクトのライフサイクルに括り付けられます。"

#~ msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
#~ msgstr "スコープの詳細については <xref linkend=\"scopescontexts\"/>で説明します。"

#~ msgid "Web Bean names and Unified EL"
#~ msgstr "Web Bean 名とユニファイド EL"

#~ msgid "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used in Unified EL expressions. It's easy to specify the name of a Web Bean:"
#~ msgstr "Web Bean は <emphasis>名前</emphasis> を持ちます。これによりユニファイド EL 式で使用することが可能になります。Web Bean の名前を指定するのは簡単です:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
#~ msgstr "これで JSF あるいは JSP ページで Web Bean を簡単に使用することができます:"

#~ msgid ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"
#~ msgstr ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"

#~ msgid "It's even easier to just let the name be defaulted by the Web Bean manager:"
#~ msgstr "Web Bean マネージャによって名前は単純にデフォルトを使用させることは一層簡単です:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "In this case, the name defaults to <literal>shoppingCart</literal> &#151; the unqualified class name, with the first character changed to lowercase."
#~ msgstr "この場合、デフォルトで名前は <literal>shoppingCart</literal> になります&#151; 最初の文字を小文字に変換した無資格のクラス名になります。"

#~ msgid "Interceptor binding types"
#~ msgstr "インタセプタバインディングタイプ"

#~ msgid "Web Beans supports the interceptor functionality defined by EJB 3, not only for EJB beans, but also for plain Java classes. In addition, Web Beans provides a new approach to binding interceptors to EJB beans and other Web Beans."
#~ msgstr "Web Beans は、 EJB beans のためにだけではなく、単純な Java クラスのためにも、EJB 3 で定義されたインタセプタ機能を提供します。さらに、Web Beans は、EJB beans と他の Web Beans へのバインディングインタセプタに新しいアプローチを提供します。"

#~ msgid "It remains possible to directly specify the interceptor class via use of the <literal>@Interceptors</literal> annotation:"
#~ msgstr "それは、<literal>@Interceptors</literal> アノテーションを使用することによりインタセプタクラスを直接指定することを可能にします:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "However, it is more elegant, and better practice, to indirect the interceptor binding through an <emphasis>interceptor binding type</emphasis>:"
#~ msgstr "しかし、<emphasis>インタセプタバインディングタイプ</emphasis> によりインタセプタバインディングを間接化することは、よりエレガントでより良い手法です:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "We'll discuss Web Beans interceptors and decorators in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/>."
#~ msgstr "Web Beans インタセプタとデコレータは <xref linkend=\"interceptors\"/> と <xref linkend=\"decorators\"/> で説明します。"

#~ msgid "What kinds of objects can be Web Beans?"
#~ msgstr "どの種類のオブジェクトが Web Beans になることができるのか"

#~ msgid "We've already seen that JavaBeans, EJBs and some other Java classes can be Web Beans. But exactly what kinds of objects are Web Beans?"
#~ msgstr "すでに JavaBean や EJB、その他のいくつかの Javaクラス が Web Beans になることを見てきました。しかし、まさにどの種類のオブジェクトが Web Beans になることができるのでしょうか。"

#~ msgid "Simple Web Beans"
#~ msgstr "単純な Web Beans"

#~ msgid "The Web Beans specification says that a concrete Java class is a <emphasis>simple</emphasis> Web Bean if:"
#~ msgstr "Web Beans 仕様では、以下の条件を満たすときに、コンクリートな Javaクラスが <emphasis>単純な</emphasis>  Web Bean になります:"

#~ msgid "it is not an EE container-managed component, like an EJB, a Servlet or a JPA entity,"
#~ msgstr "EJB やサーブレット、JPA エンティティのように EE コンテナで管理されたコンポーネントではないもの"

#~ msgid "it is not a non-static static inner class,"
#~ msgstr "静的でないインナークラスではないもの"

#~ msgid "it is not a parameterized type, and"
#~ msgstr "パラメータ化されたタイプではないもの"

#~ msgid "it has a constructor with no parameters, or a constructor annotated <literal>@Initializer</literal>."
#~ msgstr "パラメータなしのコンストラクタを持つか、あるいは <literal>@Initializer</literal> アノテーションが付与されたコンストラクタを持つもの"

#~ msgid "Thus, almost every JavaBean is a simple Web Bean."
#~ msgstr "これにより、ほとんどすべての JavaBean は単純な Web Bean です。"

#~ msgid "Every interface implemented directly or indirectly by a simple Web Bean is an API type of the simple Web Bean. The class and its superclasses are also API types."
#~ msgstr "単純な Web Bean によって直接的にまたは間接的にに実装されるすべてのインタフェースは、単純な Web Bean の API タイプです。クラスとそのクラスのスーパークラスもまた API タイプです。"

#~ msgid "Enterprise Web Beans"
#~ msgstr "エンタープライズ Web Beans"

#~ msgid "The specification says that all EJB 3-style session and singleton beans are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are not Web Beans &#151; since they are not intended to be injected into other objects &#151; but they can take advantage of most of the functionality of Web Beans, including dependency injection and interceptors."
#~ msgstr "仕様によれば、すべての EJB 3 スタイルのセッション Bean とシングルトン Bean は <emphasis>エンタープライズ</emphasis> Web Beans です。メッセージ駆動 Bean は Web Beans ではないのでしょうか。&#151;それらは他のオブジェクトへ注入されることを意図していないのですが&#151; 依存性注入とインタセプタを含む Web Beans のほとんどの機能を利用することができます。"

#~ msgid "Every local interface of an enterprise Web Bean that does not have a wildcard type parameter or type variable, and every one of its superinterfaces, is an API type of the enterprise Web Bean. If the EJB bean has a bean class local view, the bean class, and every one of its superclasses, is also an API type."
#~ msgstr "ワイルドカードタイプのパラメータまたはタイプ変数を持たないエンタープライズ Web Bean の ローカルインタフェースと、そのスーパーインタフェースのすべてが、エンタープライズ Web Bean のAPI タイプです。もし EJB Bean が ローカルビューの Bean クラスを持っていれば、Beanクラスとそのすべてのスーパークラスも APIタイプです。"

#~ msgid "Stateful session beans should declare a remove method with no parameters or a remove method annotated <literal>@Destructor</literal>. The Web Bean manager calls this method to destroy the stateful session bean instance at the end of its lifecycle. This method is called the <emphasis>destructor</emphasis> method of the enterprise Web Bean."
#~ msgstr "ステートフルなセッション beans は、パラメータのない remove メソッドまたは <literal>@Destructor</literal> アノテーションを付与された remove メソッドを宣言すべきです。Web Bean マネージャは、そのライフサイクルの終わりでステートフルセッション Bean のインスタンスを破棄するために、このメソッドを呼び出します。このメソッドは、エンタープライズ Web Bean の <emphasis>destructor</emphasis> メソッドと呼ばれます。"

#~ msgid ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"

#~ msgid "So when should we use an enterprise Web Bean instead of a simple Web Bean? Well, whenever we need the advanced enterprise services offered by EJB, such as:"
#~ msgstr "それでは、いつ単純な Web Bean でなくエンタープライズ Web Bean を使用すべきでしょうか。EJB によって提供される高度なエンタープライズサービスを必要とする場合に使用します。例えば:"

#~ msgid "method-level transaction management and security,"
#~ msgstr "メソッドレベルのトランザクション管理とセキュリティ"

#~ msgid "concurrency management,"
#~ msgstr "並行性管理"

#~ msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
#~ msgstr "ステートフルセッション Bean のためのインスタンスレベルの非活性化とステートレスセッション Bean のためのインスタンスプーリング"

#~ msgid "remote and web service invocation, and"
#~ msgstr "リモートサービスと Web サービスの呼び出し"

#~ msgid "timers and asynchronous methods,"
#~ msgstr "タイマーと非同期メソッド"

#~ msgid "we should use an enterprise Web Bean. When we don't need any of these things, a simple Web Bean will serve just fine."
#~ msgstr "エンタープライズ Web Bean を使用すべきです。これらのエンタープライズサービスのいずれもが必要ではないときには、単純な Web Bean がちょうど見事に役立つでしょう。"

#~ msgid "Many Web Beans (including any session or application scoped Web Bean) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped Web Beans should be EJBs."
#~ msgstr "多くの Web Beans(どんなセッションスコープあるいはアプリケーションスコープのWeb Beanも含む)は、並行アクセスが可能です。それゆえに、EJB 3.1 によって提供された並行性管理は特に役に立ちます。ほとんどのセッションスコープとアプリケーションスコープの Web Beans は EJB であるべきです。"

#~ msgid "Web Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> model, with its support for passivation and instance pooling."
#~ msgstr "ヘビー級のリソースへの参照を保持あるいは多くの内部状態を保持する Web Beans は、EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> モデル によって定義された高度なコンテナで管理されたライフサイクルから恩恵を受け、非活性化とインスタンスプーリングに対するサポートも利用できます。"

#~ msgid "Finally, it's usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
#~ msgstr "最後に、メソッドレベルのトランザクション管理、メソッドレベルのセキュリティ、タイマー、リモートメソッドあるいは非同期メソッドが必要とされる場合はたいてい明らかです。"

#~ msgid "It's usually easy to start with simple Web Bean, and then turn it into an EJB, just by adding an annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
#~ msgstr "通常は単純な Web Bean で始めるのが簡単です。それから、単に <literal>@Stateless</literal> や <literal>@Stateful</literal>、<literal>@Singleton</literal> アノテーションを付け加えることによって、それらをEJBに変えてください。"

#~ msgid "Producer methods"
#~ msgstr "プロデューサ (producer) メソッド"

#~ msgid "A <emphasis>producer method</emphasis> is a method that is called by the Web Bean manager to obtain an instance of the Web Bean when no instance exists in the current context. A producer method lets the application take full control of the instantiation process, instead of leaving instantiation to the Web Bean manager. For example:"
#~ msgstr "<emphasis>プロデューサメソッド</emphasis> は、現在のコンテキストにインスタンスが存在しないときに、Web Bean のインスタンスを得るために Web Bean マネージャ によって呼ばれるメソッドです。プロデューサメソッドは、インスタンス化を Web Bean マネージャに委ねるのではなく、アプリケーションにインスタンス化プロセスの完全な管理をさせます。例えば:"

#~ msgid ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "The result of a producer method is injected just like any other Web Bean."
#~ msgstr "プロデューサメソッドの結果は、ちょうど他のWeb Beanのように注入されます。"

#~ msgid "<![CDATA[@Random int randomNumber]]>"
#~ msgstr "<![CDATA[@Random int randomNumber]]>"

#~ msgid "The method return type and all interfaces it extends/implements directly or indirectly are API types of the producer method. If the return type is a class, all superclasses are also API types."
#~ msgstr "メソッドの戻りタイプとそれが直接的にあるいは間接的に拡張する/実装するすべてのインタフェースはプロデューサメソッドの API タイプです。もし戻りのタイプがクラスならは、すべてのスーパークラスもAPI タイプです。"

#~ msgid "Some producer methods return objects that require explicit destruction:"
#~ msgstr "プロデューサメソッドは、明示的な破棄を必要とするオブジェクトを返すものもあります:"

#~ msgid ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"

#~ msgid "These producer methods may define matching <emphasis>disposal methods</emphasis>:"
#~ msgstr "これらのプロデューサメソッドは、適合する <emphasis> ディスポーザルメソッド</emphasis> を定義するかもしれません: "

#~ msgid ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"

#~ msgid "This disposal method is called automatically by the Web Bean manager at the end of the request."
#~ msgstr "このディスポーザルメソッドは、リクエストの終わりに Web Bean マネージャ によって自動的に呼び出されます。"

#~ msgid "We'll talk much more about producer methods in <xref linkend=\"producermethods\"/>."
#~ msgstr "プロデューサメソッドについての詳細は <xref linkend=\"producermethods\"/> で説明します。"

#~ msgid "JMS endpoints"
#~ msgstr "JMS エンドポイント"

#~ msgid "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the developer from the tedium of managing the lifecycles of all the various JMS objects required to send messages to queues and topics. We'll discuss JMS endpoints in <xref linkend=\"jms\"/>."
#~ msgstr "最後に、JMS キューまたはトピックは、Web Bean になることができます。Web Beans は、キューとトピックにメッセージを送るために必要となる、すべての様々な JMS オブジェクトのライフサイクルを管理する退屈から開発者を開放します。JMS エンドポイントは <xref linkend=\"jms\"/> で説明します。"
