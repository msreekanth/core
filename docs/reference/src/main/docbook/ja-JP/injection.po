# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-12-14T13:35:17\n"
"PO-Revision-Date: 2009-06-02 01:32+0900\n"
"Last-Translator: Daisuke Sano <d-sano@nri.co.jp>\n"
"Language-Team: none\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, fuzzy, no-c-format
msgid "Dependency injection and programmatic lookup"
msgstr "依存性注入"

#. Tag: para
#, no-c-format
msgid "One of the most significant features of CDI—certainly the most recognized—is dependency injection; excuse me, <emphasis>typesafe</emphasis> dependency injection."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Injection points"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The <literal>@Inject</literal> annotation lets us define an injection point that is injected during bean instantiation. Injection can occur via three different mechanisms."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Bean constructor</emphasis> parameter injection:"
msgstr "<emphasis>初期化</emphasis>メソッドの引数による注入、"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can only have one injectable constructor."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Initializer method</emphasis> parameter injection:"
msgstr "<emphasis>初期化</emphasis>メソッドの引数による注入、"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can have multiple initializer methods. If the bean is a session bean, the initializer method is not required to be a business method of the session bean."
msgstr ""

#. Tag: para
#, no-c-format
msgid "And direct field injection:"
msgstr "そして、フィールドへの直接的な注入です。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Getter and setter methods are not required for field injection to work (unlike with JSF managed beans)."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Dependency injection always occurs when the bean instance is first instantiated by the container. Simplifying just a little, things happen in this order:"
msgstr "依存性注入は、Web Beanインスタンスが最初に生成される際に必ず行われます。"

#. Tag: para
#, fuzzy, no-c-format
msgid "First, the container calls the bean constructor (the default constructor or the one annotated <literal>@Inject</literal>), to obtain an instance of the bean."
msgstr "最初に、Web Beanマネージャは、Web Beanインスタンスを取得するために、Web Beanのコンストラクタを実行する"

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container initializes the values of all injected fields of the bean."
msgstr "次に、Web Beanマネージャは、Web Beanの、注入すべきすべてのフィールド値を初期化する"

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container calls all initializer methods of bean (the call order is not portable, don&#39;t rely on it)."
msgstr "次に、Web Beanマネージャは、Web Beanの、すべての初期化メソッドを実行する"

#. Tag: para
#, fuzzy, no-c-format
msgid "Finally, the <literal>@PostConstruct</literal> method, if any, is called."
msgstr "最後に、もしあれば、Web Beanの<literal>@PostConstruct</literal>メソッドが呼ばれます。"

#. Tag: para
#, no-c-format
msgid "(The only complication is that the container might call initializer methods declared by a superclass before initializing injected fields declared by a subclass.)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "One major advantage of constructor injection is that it allows the bean to be immutable."
msgstr ""

#. Tag: para
#, no-c-format
msgid "CDI also supports parameter injection for some other methods that are invoked by the container. For instance, parameter injection is supported for producer methods:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}"
msgstr ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "This is a case where the <literal>@Inject</literal> annotation <emphasis>is not</emphasis> required at the injection point. The same is true for observer methods (which we&#39;ll meet in <xref linkend=\"events\" />) and disposer methods."
msgstr ""

#. Tag: title
#, no-c-format
msgid "What gets injected"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "The CDI specification defines a procedure, called <emphasis>typesafe resolution</emphasis>, that the container follows when identifying the bean to inject to an injection point. This algorithm looks complex at first, but once you understand it, it&#39;s really quite intuitive. Typesafe resolution is performed at system initialization time, which means that the container will inform the developer immediately if a bean&#39;s dependencies cannot be satisfied."
msgstr "Web Beansの仕様では、<emphasis>タイプセーフ解決アルゴリズム</emphasis>が定義されており、Web Beanマネージャは、ある注入箇所への注入を行う際、これにのっとって、注入すべきWeb Beanを特定します。このアルゴリズムは最初は複雑に感じますが、一度理解してしまえば、とても直観的なものです。タイプセーフ解決アルゴリズムは、システムの初期化時に使われます。これは、もしWeb Beanの依存性が充たされない場合には、マネージャが<literal>UnsatisfiedDependencyException</literal>や<literal>AmbiguousDependencyException</literal>をスローすることによって、即座にそれをユーザに通知することを意味します。"

#. Tag: para
#, fuzzy, no-c-format
msgid "The purpose of this algorithm is to allow multiple beans to implement the same bean type and either:"
msgstr "このアルゴリズムの目的は、複数のWeb Beanが同じAPIを実装できるようにすることであり、"

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the client to select which implementation it requires using a <emphasis>qualifier</emphasis> or"
msgstr "<emphasis>バインディングアノテーション</emphasis>を使用することによって、クライアントが必要とする実装を選択できるようにする"

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the application deployer to select which implementation is appropriate for a particular deployment, without changes to the client, by enabling or disabling an <emphasis>alternative</emphasis>, or"
msgstr "アプリケーションをデプロイする際に<emphasis>デプロイメントタイプ</emphasis>を有効にしたり無効にしたりすることによって、クライアントを変更することなく、特定の環境に対して適切な実装を選択できるようにする"

#. Tag: para
#, no-c-format
msgid "allow the beans to be isolated into separate modules."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Obviously, if you have exactly one bean of a given type, and an injection point with that same type, then bean A is going to go into slot A. That&#39;s the simplest possible scenario. When you first start your application, you&#39;ll likely have lots of those."
msgstr ""

#. Tag: para
#, no-c-format
msgid "But then, things start to get complicated. Let&#39;s explore how the container determines which bean to inject in more advanced cases. We&#39;ll start by taking a closer look at qualifiers."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Qualifier annotations"
msgstr "バインディングアノテーション"

#. Tag: para
#, fuzzy, no-c-format
msgid "If we have more than one bean that implements a particular bean type, the injection point can specify exactly which bean should be injected using a qualifier annotation. For example, there might be two implementations of <literal>PaymentProcessor</literal>:"
msgstr "もし一つより多いWeb Beanが特定のAPIを実装している場合、注入箇所では、バインディングアノテーションを使用することによって、どのWeb Beanが注入されるべきかということが正確に指定されます。例えば、ここに<literal>PaymentProcessor</literal>に対する二つの実装が存在するとします。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> are qualifier annotations:"
msgstr "ここで、<literal>@PayByCheque</literal>と<literal>@PayByCreditCard</literal>はバインディングアノテーションです。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "A client bean developer uses the qualifier annotation to specify exactly which bean should be injected."
msgstr "クライアントWeb Beanの開発者は、バインディングアノテーションを使用することによって、どのWeb Beanが注入されるべきかということを、正確に指定することができます。"

#. Tag: para
#, no-c-format
msgid "Using field injection:"
msgstr "フィールドに注入することができます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;"
msgstr ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#, no-c-format
msgid "Using initializer method injection:"
msgstr "初期化メソッドを使用して注入することもできます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Using constructor injection:"
msgstr "そして、コンストラクタを使用して注入することもできます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Qualifier annotations can also qualify method arguments of producer, disposer and observer methods. Combining qualified arguments with producer methods is a good way to have an implementation of a bean type selected at runtime based on the state of the system:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "If an injected field or a parameter of a bean constructor or initializer method is not explicitly annotated with a qualifier, the default qualifier, <literal>@Default</literal>, is assumed."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, you may be thinking, <emphasis>&#34;What&#39;s the different between using a qualifier and just specifying the exact implementation class you want?&#34;</emphasis> It&#39;s important to understand that a qualifier is like an extension of the interface. It does not create a direct dependency to any particular implementation. There may be multiple alterative implementations of <literal>@Asynchronous PaymentProcessor</literal>!"
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "The built-in qualifiers <literal>@Default</literal> and <literal>@Any</literal>"
msgstr "シンプルWeb Beanは<literal>@PostConstruct</literal>と<literal>@PreDestroy</literal>のみをコールバックとしてサポートします。"

#. Tag: para
#, no-c-format
msgid "Whenever a bean or injection point does not explicitly declare a qualifier, the container assumes the qualifier <literal>@Default</literal>. From time to time, you&#39;ll need to decare an injection point without specifying a qualifier. There&#39;s a qualifier for that too. All beans have the qualifier <literal>@Any</literal>. Therefore, by explicitly specifying <literal>@Any</literal> at an injection point, you suppress the default qualifier, without otherwise restricting the beans that are eligible for injection."
msgstr ""

#. Tag: para
#, no-c-format
msgid "This is especially useful if you want to iterate over all beans with a certain bean type. For example:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject \n"
"void initServices(@Any Instance&#60;Service&#62; services) { \n"
"   for (Service service: services) {\n"
"      service.init();\n"
"   }\n"
"}"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Qualifiers with members"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java annotations can have members. We can use annotation members to further discriminate a qualifier. This prevents a potential explosion of new annotations. For example, instead of creating several qualifiers representing different payment methods, we could aggregate them into a single annotation with a member:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Then we select one of the possible member values when appling the qualifier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We can force the container to ignore a member of a qualifier type by annotating the member <literal>@Nonbinding</literal>."
msgstr "バインディングアノテーションタイプのメンバーに@NonBindingアノテーションをつけることによって、Web Beanマネージャがメンバを無視するように指定することもできます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @Nonbinding String comment() default &#34;&#34;;\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Multiple qualifiers"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "An injection point may specify multiple qualifiers:"
msgstr "注入箇所に、複数のバインディングアノテーションを指定することもできます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Then only a bean which has <emphasis>both</emphasis> qualifier annotations would be eligible for injection."
msgstr "このような場合、<emphasis>両方の</emphasis>バインディングアノテーションを持つWeb Beanのみが、注入する対象として適格となります。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Alternatives"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatives are beans whose implementation is specific to a particular client module or deployment scenario. This alternative defines a mock implementation of both <literal>@Synchronous PaymentProcessor</literal> and <literal>@Asynchronous PaymentProcessor</literal>, all in one:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "By default, <literal>@Alternative</literal> beans are disabled. We need to <emphasis>enable</emphasis> an alternative in the <literal>beans.xml</literal> descriptor of a bean archive to make it available for instantiation and injection. This activation only applies to the beans in that archive."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"&#60;beans\n"
"   xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34;\n"
"   xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;\n"
"   xsi:schemaLocation=&#34;\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd&#34;&#62;\n"
"   &#60;alternatives&#62;\n"
"         &#60;class&#62;org.mycompany.mock.MockPaymentProcessor&#60;/class&#62;\n"
"   &#60;/alternatives&#62;\n"
"&#60;/beans&#62;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "When an ambiguous dependency exists at an injection point, the container attempts to resolve the ambiguity by looking for an enabled alternative among the beans that could be injected. If there is exactly one enabled alternative, that&#39;s the bean that will be injected."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Fixing unsatisfied and ambiguous dependencies"
msgstr "依存性を充たすように修正する"

#. Tag: para
#, fuzzy, no-c-format
msgid "The typesafe resolution algorithm fails when, after considering the qualifier annotations on all beans that implement the bean type of an injection point and filtering out disabled beans (<literal>@Alternative</literal> beans which are not explicitly enabled), the container is unable to identify exactly one bean to inject. The container will abort deployment, informing us of the unsatisfied or ambiguous dependency."
msgstr "注入箇所のAPIタイプを実装したすべてのWeb Beanのバインディングアノテーションやデプロイメントタイプを考慮した結果、Web Beanマネージャが注入すべきWeb Beanを一つに絞りきれない場合、タイプセーフな解決アルゴリズムは失敗します。"

#. Tag: para
#, no-c-format
msgid "During the course of your development, you&#39;re going to encounter this situation. Let&#39;s learn how to resolve it."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>unsatisfied dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "create a bean which implements the bean type and has all the qualifier types of the injection point,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "make sure that the bean you already have is in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "explicitly enable an <literal>@Alternative</literal> bean that implements the bean type and has the appropriate qualifier types, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>ambiguous dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce a qualifier to distinguish between the two implementations of the bean type,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of the beans by annotating it <literal>@Alternative</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "move one of the implementations to a module that is not in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of two <literal>@Alternative</literal> beans that are trying to occupy the same space, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "See <ulink url=\"http://sfwk.org/Documentation/HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType\">this FAQ</ulink> for step-by-step instructions for how to resolve an ambigous resolution exception between a raw bean type and a producer method that returns the same bean type."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Just remember: &#34;There can be only one.&#34;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "On the other hand, if you really do have an optional or multivalued injection point, you should change the type of your injection point to <literal>Instance</literal>, as we&#39;ll see in <xref linkend=\"lookup\" />."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Now there&#39;s one more issue you need to be aware of when using the dependency injection service."
msgstr "Web Beansにおける依存性注入を行う際に気をつけるべきことが、もう少しあります。"

#. Tag: title
#, no-c-format
msgid "Client proxies"
msgstr "クライアントプロキシ"

#. Tag: para
#, fuzzy, no-c-format
msgid "Clients of an injected bean do not usually hold a direct reference to a bean instance, unless the bean is a dependent object (scope <literal>@Dependent</literal>)."
msgstr "注入されたWeb Beanのクライアントは、通常、Web Beanインスタンスに対する直接的な参照を持ちません。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Imagine that a bean bound to the application scope held a direct reference to a bean bound to the request scope. The application-scoped bean is shared between many different requests. However, each request should see a different instance of the request scoped bean—the current one!"
msgstr "アプリケーションスコープに結び付けられたWeb Beanが、リクエストスコープに結び付けられたWeb Beanに対する直接的な参照を持っている場合を想像してみてください。アプリケーションスコープのWeb Beanは、たくさんの異なるリクエスト間で共有されます。しかしながら、それぞれのリクエストは、それぞれ異なったリクエストスコープのWeb Beanインスタンスを参照するべきなのです。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Now imagine that a bean bound to the session scope holds a direct reference to a bean bound to the application scope. From time to time, the session context is serialized to disk in order to use memory more efficiently. However, the application scoped bean instance should not be serialized along with the session scoped bean! It can get that reference any time. No need to hoard it!"
msgstr "今度は、セッションスコープに結び付けられたWeb Beanが、アプリケーションスコープに結び付けられたWeb Beanに対する直接的な参照を持っている場合を想像してみてください。セッションコンテキストは、メモリを効率的に使う目的で、時々ディスクにシリアライズされます。しかしながら、アプリケーションスコープのWeb Beanインスタンスは、セッションスコープのWeb Beanインスタンスと一緒にシリアライズされるべきではないのです。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Therefore, unless a bean has the default scope <literal>@Dependent</literal>, the container must indirect all injected references to the bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible for ensuring that the bean instance that receives a method invocation is the instance that is associated with the current context. The client proxy also allows beans bound to contexts such as the session context to be serialized to disk without recursively serializing other injected beans."
msgstr "それゆえWeb Beanマネージャは、Web Beanがデフォルトスコープである<literal>@Dependent</literal>を持っていない限り、すべての注入されたWeb Beanへの参照を、プロキシオブジェクトを通じて間接的に行わなければなりません。この<emphasis>クライアントプロキシ</emphasis>は、メソッドが起動されるWeb Beanインスタンスと、現在のコンテキストに結びついたインスタンスが同一であることを保証する責任を持ちます。またクライアントプロキシは、セッションコンテキストのようなコンテキストに結び付けられたWeb Beanが、他の注入されたWeb Beanを再帰的にシリアライズすることなく、シリアライズすることを可能とします。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the container. If an injection point declared with one of these types resolves to a bean with any scope other than <literal>@Dependent</literal>, the container will abort deployment, informing us of the problem."
msgstr "不幸にも、Java言語の制限により、いくつかのJavaタイプはWeb Beanマネージャがプロキシ化することができません。それゆえ、注入箇所のタイプがプロキシ化できないものである場合、Web Beanマネージャは<literal>UnproxyableDependencyException</literal>をスローします。"

#. Tag: para
#, fuzzy, no-c-format
msgid "The following Java types cannot be proxied by the container:"
msgstr "次に挙げるJava型はWeb Beanマネージャがプロキシ化することができません。"

#. Tag: para
#, fuzzy, no-c-format
msgid "classes which don&#39;t have a non-private constructor with no parameters, and"
msgstr "プライベートでなく、引数を持たないコンストラクタを持たないクラス"

#. Tag: para
#, no-c-format
msgid "classes which are declared <literal>final</literal> or have a <literal>final</literal> method,"
msgstr "<literal>final</literal>宣言されたクラスや、<literal>final</literal>メソッドを持つクラス"

#. Tag: para
#, no-c-format
msgid "arrays and primitive types."
msgstr "配列とプリミティブ型"

#. Tag: para
#, no-c-format
msgid "It&#39;s usually very easy to fix an unproxyable dependency problem. If an injection point of type <literal>X</literal> results in an unproxyable dependency, simply:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "add a constructor with no parameters to <literal>X</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "change the type of the injection point to <literal>Instance&#60;X&#62;</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce an interface <literal>Y</literal>, implemented by the injected bean, and change the type of the injection point to <literal>Y</literal>, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "A future release of Weld will likely support a non-standard workaround for this limitation, using non-portable JVM APIs:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most efficient)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "IBM, JRockit: <literal>ReflectionFactory.newConstructorForSerialization()</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "But we didn&#39;t get around to implementing this yet."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Obtaining a contextual instance by programmatic lookup"
msgstr "ルックアップ処理によるWeb Beanの取得"

#. Tag: para
#, no-c-format
msgid "In certain situations, injection is not the most convenient way to obtain a contextual reference. For example, it may not be used when:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "the bean type or qualifiers vary dynamically at runtime, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "we would like to iterate over all beans of a certain type."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "In these situations, the application may obtain an instance of the interface <literal>Instance</literal>, parameterized for the bean type, by injection:"
msgstr "アプリケーションは注入によって、<literal>Manager</literal>インタフェースを持つインスタンスを取得することができます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "The <literal>get()</literal> method of <literal>Instance</literal> produces a contextual instance of the bean."
msgstr "テスト作業における<literal>@Mock</literal>や<literal>@Staging</literal>の使用"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "PaymentProcessor p = paymentProcessorSource.get();"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Qualifiers can be specified in one of two ways:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "by annotating the <literal>Instance</literal> injection point, or"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "by passing qualifiers to the <literal>select()</literal> of <literal>Event</literal>."
msgstr "シンプルWeb Beanは<literal>@PostConstruct</literal>と<literal>@PreDestroy</literal>のみをコールバックとしてサポートします。"

#. Tag: para
#, no-c-format
msgid "Specifying the qualifiers at the injection point is much, much easier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Asynchronous Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Now, the <literal>PaymentProcessor</literal> returned by <literal>get()</literal> will have the qualifier <literal>@Asynchronous</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatively, we can specify the qualifier dynamically. First, we add the <literal>@Any</literal> qualifier to the injection point, to suppress the default qualifier. (All beans have the qualifier <literal>@Any</literal>.)"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Any Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Next, we need to obtain an instance of our qualifier type. Since annotatons are interfaces, we can&#39;t just write <literal>new Asynchronous()</literal>. It&#39;s also quite tedious to create a concrete implementation of an annotation type from scratch. Instead, CDI lets us obtain a qualifier instance by subclassing the helper class <literal>AnnotationLiteral</literal>."
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral&#60;Asynchronous&#62; implements Asynchronous {}"
msgstr ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"

#. Tag: para
#, no-c-format
msgid "In some cases, we can use an anonymous class:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral&#60;Asynchronous&#62;() {});"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new AnnotationLiteral<CreditCard>(){});]]>"

#. Tag: para
#, no-c-format
msgid "We can&#39;t use an anonymous class to implement a qualifier type with members."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, finally, we can pass the qualifier to the <literal>select()</literal> method of <literal>Instance</literal>."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);"
msgstr ""

#. Tag: title
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "<literal>InjectionPoint</literal>オブジェクト"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are certain kinds of dependent objects (beans with scope <literal>@Dependent</literal>) that need to know something about the object or injection point into which they are injected in order to be able to do what they do. For example:"
msgstr "ある種の依存性を持ったオブジェクト、<literal>@Dependent</literal>スコープを持ったWeb Beanは、それらが機能するために注入されたオブジェクトや注入箇所についての情報が必要になります。例えば、"

#. Tag: para
#, no-c-format
msgid "The log category for a <literal>Logger</literal> depends upon the class of the object that owns it."
msgstr "<literal>Logger</literal>のログカテゴリはロガーを保有するオブジェクトのクラスが何であるかに依存します。"

#. Tag: para
#, no-c-format
msgid "Injection of a HTTP parameter or header value depends upon what parameter or header name was specified at the injection point."
msgstr "HTTPパラメタ値やヘッダ値の注入は、注入箇所において、どのパラメタ名やヘッダ名が指定されているかに依存します。"

#. Tag: para
#, no-c-format
msgid "Injection of the result of an EL expression evaluation depends upon the expression that was specified at the injection point."
msgstr "EL式の評価結果の注入は、注入箇所においてどのような式が指定されているかに依存します。"

#. Tag: para
#, fuzzy, no-c-format
msgid "A bean with scope <literal>@Dependent</literal> may inject an instance of <literal>InjectionPoint</literal> and access metadata relating to the injection point to which it belongs."
msgstr "<literal>@Dependent</literal>スコープを持ったWeb Beanは、<literal>InjectionPoint</literal>のインスタンスに注入を行い、Web Beanが属する注入箇所に関するメタデータにアクセスする可能性があります。"

#. Tag: para
#, fuzzy, no-c-format
msgid "Let&#39;s look at an example. The following code is verbose, and vulnerable to refactoring problems:"
msgstr "例を見てみましょう。次のコードは、煩雑なうえに、リファクタリングしにくいコードです。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "Logger log = Logger.getLogger(MyClass.class.getName());"
msgstr "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"

#. Tag: para
#, no-c-format
msgid "This clever little producer method lets you inject a JDK <literal>Logger</literal> without explicitly specifying the log category:"
msgstr "次の賢く小さなプロデューサメソッドは、明示的にログカテゴリを指定することなくJDKの<literal>Logger</literal>を注入します。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "We can now write:"
msgstr "これによって、次のような記述が可能になります。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Logger log;"
msgstr "<![CDATA[@Current Logger log;]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Not convinced? Then here&#39;s a second example. To inject HTTP parameters, we need to define a qualifier type:"
msgstr "納得できませんか？もう一つの例を見てみましょう。HTTPパラメタを注入するためには、バインディングタイプを定義する必要があります。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @Nonbinding public String value();\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We would use this qualifier type at injection points as follows:"
msgstr "このバインディングタイプを注入箇所において、次のように使うことができます。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@HttpParam(&#34;username&#34;) String username;\n"
"@HttpParam(&#34;password&#34;) String password;"
msgstr ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"

#. Tag: para
#, no-c-format
msgid "The following producer method does the work:"
msgstr "次のプロデューサメソッドが動作します。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class HttpParams\n"
"\n"
"   @Produces @HttpParam(&#34;&#34;)\n"
"   String getParamValue(InjectionPoint ip) {\n"
"      ServletRequest request = (ServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n"
"      return request.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Note that acquiring of the request in this example is JSF-centric. For a more generic solution you could write your own prodcuer for the request and have it injected as a method parameter."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Note also that the <literal>value()</literal> member of the <literal>HttpParam</literal> annotation is ignored by the container since it is annotated <literal>@Nonbinding.</literal>"
msgstr "（<literal>HttpParam</literal>アノテーションの<literal>value()</literal>メンバーは、<literal>@NonBinding</literal>アノテーションが付いているので、Web Beanマネージャには無視されることに注意して下さい。）"

#. Tag: para
#, fuzzy, no-c-format
msgid "The container provides a built-in bean that implements the <literal>InjectionPoint</literal> interface:"
msgstr "Web Beanマネージャは<literal>InjectionPoint</literal>インタフェースを実装した組み込みWeb Beanを提供します。"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public interface InjectionPoint { \n"
"   public Type getType();\n"
"   public Set&#60;Annotation&#62; getQualifiers();\n"
"   public Bean&#60;?&#62; getBean();\n"
"   public Member getMember();\n"
"   public Annotated getAnnotated();\n"
"   public boolean isDelegate();\n"
"   public boolean isTransient();\n"
"}"
msgstr ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"

#, fuzzy
#~ msgid "It's usually very easy to fix an unproxyable dependency problem. Simply add a constructor with no parameters to the injected class, introduce an interface, or, if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
#~ msgstr "通常、<literal>UnproxyableDependencyException</literal>を修正することはとても簡単です。単に、引数のないコンストラクタを注入されるクラスに追加したり、インタフェースを導入したり、注入されるWeb Beanのスコープを<literal>@Dependent</literal>に変更するだけです。"

#~ msgid "Web Beans supports three primary mechanisms for dependency injection:"
#~ msgstr "Web Beansは依存性注入のための3つの基本的な機構を持っています。"

#~ msgid "Constructor parameter injection:"
#~ msgstr "コンストラクタの引数による注入、"

#~ msgid "Constructor parameter injection is not supported for EJB beans, since the EJB is instantiated by the EJB container, not the Web Bean manager."
#~ msgstr "コンストラクタの引数による注入は、EJBには使用することができません。なぜならば、EJBはWeb Beanマネージャではなく、EJBコンテナによって初期化が行われるからです。"

#~ msgid "Parameters of constructors and initializer methods need not be explicitly annotated when the default binding type <literal>@Current</literal> applies. Injected fields, however, <emphasis>must</emphasis> specify a binding type, even when the default binding type applies. If the field does not specify a binding type, it will not be injected."
#~ msgstr "コンストラクタや初期化メソッドの引数で注入を行う場合には、デフォルトで<literal>@Current</literal>バインディングタイプが適用されるので、明示的なアノテーションは必要ありません。しかしながら、フィールドへの直接的な注入を行う場合には、デフォルトのバインディングタイプで良い場合でも、バインディングタイプを指定<emphasis>しなければなりません</emphasis>。バインディングタイプを指定しない場合は、注入は行われません。"

#~ msgid "Producer methods also support parameter injection:"
#~ msgstr "プロデューサメソッドもまた、引数による注入を可能とします。"

#~ msgid "Finally, observer methods (which we'll meet in <xref linkend=\"events\"/>), disposal methods and destructor methods all support parameter injection."
#~ msgstr "結局、オブザーバメソッド（<xref linkend=\"events\"/>で紹介します）や、ディスポーザルメソッド、デストラクタでも引数による注入が可能です。"

#~ msgid "allow one implementation of an API to override another implementation of the same API at deployment time, without changes to the client, using <emphasis>deployment type precedence</emphasis>."
#~ msgstr "<emphasis>デプロイメントタイプの優先度</emphasis>を使用することによって、クライアントを変更することなく、APIのとある実装が同じAPIの異なる実装を、デプロイメント時に上書きできるようにする"

#~ msgid "Let's explore how the Web Beans manager determines a Web Bean to be injected."
#~ msgstr "それでは、Web Beanマネージャが注入すべきWeb Beanをどのように決定していくのかを見ていくことにしましょう。"

#~ msgid ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"

#~ msgid "Binding annotations with members"
#~ msgstr "メンバー付きのバインディングアノテーション"

#~ msgid "Binding annotations may have members:"
#~ msgstr "バインディングアノテーションはメンバーを持つことができます。"

#~ msgid "In which case, the member value is significant:"
#~ msgstr "このような場合には、メンバーの値が重要な意味を持ちます。"

#~ msgid ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"
#~ msgstr ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"

#~ msgid "Combinations of binding annnotations"
#~ msgstr "バインディングアノテーションの組み合わせ"

#~ msgid "Binding annotations and producer methods"
#~ msgstr "バインディングアノテーションとプロデューサメソッド"

#~ msgid "Even producer methods may specify binding annotations:"
#~ msgstr "プロデューサメソッドでバインディングアノテーションを指定することもできます。"

#~ msgid ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"

#~ msgid "The default binding type"
#~ msgstr "デフォルトのバインディングタイプ"

#~ msgid "Web Beans defines a binding type <literal>@Current</literal> that is the default binding type for any injection point or Web Bean that does not explicitly specify a binding type."
#~ msgstr "Web Beansでは、デフォルトのバインディングタイプ<literal>@Current</literal>が定義されており、明示的なバインディングタイプの指定が行われていないすべての注入箇所やWeb Beanに適用されます。"

#~ msgid "There are two common circumstances in which it is necessary to explicitly specify <literal>@Current</literal>:"
#~ msgstr "以下の二つの状況においては、<literal>@Current</literal>を明示的に指定する必要があります。"

#~ msgid "on a field, in order to declare it as an injected field with the default binding type, and"
#~ msgstr "フィールドの定義において、そのフィールドがデフォルトのバインディングタイプによって注入される（フィールドが持つ型によって解決される）フィールドであることを宣言する場合"

#~ msgid "on a Web Bean which has another binding type in addition to the default binding type."
#~ msgstr "Web Beanの定義において、そのWeb Beanがデフォルトのバインディングタイプ（Web Beanが持つ型によって解決される）に加えて別のバインディングタイプを持つ場合"

#~ msgid "Deployment types"
#~ msgstr "デプロイメントタイプ"

#~ msgid "All Web Beans have a <emphasis>deployment type</emphasis>. Each deployment type identifies a set of Web Beans that should be conditionally installed in some deployments of the system."
#~ msgstr "すべてのWeb Beanは<emphasis>デプロイメントタイプ</emphasis>を持ちます。それぞれのデプロイメントタイプは、システムのある構成の下で条件つきでインストールされるべきWeb Beanの集合を規定します。"

#~ msgid "For example, we could define a deployment type named <literal>@Mock</literal>, which would identify Web Beans that should only be installed when the system executes inside an integration testing environment:"
#~ msgstr "例えば、<literal>@Mock</literal>という名前のデプロイメントタイプを定義し、結合テスト環境の中でシステムが稼動するときにのみインストールされるべきWeb Beanを規定するようなことができます。"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"

#~ msgid "Suppose we had some Web Bean that interacted with an external system to process payments:"
#~ msgstr "支払い処理を行う外部システムに関連したあるWeb Beanがあると想定します。"

#~ msgid ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#~ msgid "Since this Web Bean does not explicitly specify a deployment type, it has the default deployment type <literal>@Production</literal>."
#~ msgstr "このWeb Beanは明示的にデプロイメントタイプが指定されていないので、デフォルトのデプロイメントタイプである<literal>@Production</literal>を持つことになります。"

#~ msgid "For integration or unit testing, the external system is slow or unavailable. So we would create a mock object:"
#~ msgstr "結合テストや単体テストを行う際に、外部システムの処理が遅かったり、使用できなかったりする場合には、このようにモックオブジェクトを作成することでしょう。"

#~ msgid ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "But how does the Web Bean manager determine which implementation to use in a particular deployment?"
#~ msgstr "しかし、Web Beamマネージャは一体どのようにして、そのような特定の環境で使われる実装を決定するのでしょうか？"

#~ msgid "Enabling deployment types"
#~ msgstr "デプロイメントタイプを有効にする"

#~ msgid "Web Beans defines two built-in deployment types: <literal>@Production</literal> and <literal>@Standard</literal>. By default, only Web Beans with the built-in deployment types are enabled when the system is deployed. We can identify additional deployment types to be enabled in a particular deployment by listing them in <literal>web-beans.xml</literal>."
#~ msgstr "Web Beansは、<literal>@Production</literal>と<literal>@Standard</literal>という、二つの組み込みデプロイメントタイプを定めています。システムがデプロイされた際に、デフォルトでは、組み込みデプロイメントタイプを持つWeb Beanのみが有効となります。特定の環境で有効となるような付加的なデプロイメントタイプを規定するためには、それらを<literal>web-beans.xml</literal>に列挙します。"

#~ msgid "Going back to our example, when we deploy our integration tests, we want all our <literal>@Mock</literal> objects to be installed:"
#~ msgstr "先程の例に戻ると、結合テストをデプロイするには、すべての<literal>@Mock</literal>オブジェクトをインストールする必要があります。"

#~ msgid ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"
#~ msgstr ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"

#~ msgid "Now the Web Bean manager will identify and install all Web Beans annotated <literal>@Production</literal>, <literal>@Standard</literal> or <literal>@Mock</literal> at deployment time."
#~ msgstr "このようにすることで、Web Beanマネージャは、デプロイ時に、<literal>@Production</literal>、<literal>@Standard</literal>、<literal>@Mock</literal>のアノテーションが付加されたすべてのWeb Beanを規定し、インストールします。"

#~ msgid "The deployment type <literal>@Standard</literal> is used only for certain special Web Beans defined by the Web Beans specification. We can't use it for our own Web Beans, and we can't disable it."
#~ msgstr "<literal>@Standard</literal>デプロイメントタイプは、Web Beans仕様で定められた、ある特別なWeb Beanに対してのみ使用されます。開発者が作成したWeb Beanに対してこれを使用したり、デプロイメントタイプを無効にしたりすることはできません。"

#~ msgid "The deployment type <literal>@Production</literal> is the default deployment type for Web Beans which don't explicitly declare a deployment type, and may be disabled."
#~ msgstr "<literal>@Production</literal>デプロイメントタイプは、明示的にデプロイメントタイプが宣言されないWeb Beanのデフォルトのデプロイメントタイプであり、無効にすることもできます。"

#~ msgid "Deployment type precedence"
#~ msgstr "デプロイメントタイプの優先度"

#~ msgid "If you've been paying attention, you're probably wondering how the Web Bean manager decides which implementation &#151; <literal>ExternalPaymentProcessor</literal> or <literal>MockPaymentProcessor</literal> &#151; to choose. Consider what happens when the manager encounters this injection point:"
#~ msgstr "ここまで注意深く読み進めてきた方は、Web Beanマネージャが、一体どうやって<literal>ExternalPaymentProcessor</literal>と<literal>MockPaymentProcessor</literal>のどちらの実装を選択するかを決定するのかという点について、疑問に思われるかもしれません。マネージャがこのような注入箇所に遭遇した場合に、何が起こっているのかを考えてみましょう。"

#~ msgid "There are now two Web Beans which satisfy the <literal>PaymentProcessor</literal> contract. Of course, we can't use a binding annotation to disambiguate, since binding annotations are hard-coded into the source at the injection point, and we want the manager to be able to decide at deployment time!"
#~ msgstr "今、<literal>PaymentProcessor</literal>の条件を充たす二つのWeb Beanが存在します。もちろん、曖昧さを排除するようなバインディングアノテーションを用いることはできません。なぜならば、そうするにはバインディングアノテーションをソースの注入箇所にハードコーディングする必要があり、我々が行いたいのはそうではなく、デプロイ時に、マネージャによって決定されるようにしたいからです。"

#~ msgid "The solution to this problem is that each deployment type has a different <emphasis>precedence</emphasis>. The precedence of the deployment types is determined by the order in which they appear in <literal>web-beans.xml</literal>. In our example, <literal>@Mock</literal> appears later than <literal>@Production</literal> so it has a higher precedence."
#~ msgstr "このような問題への解として、それぞれのデプロイメントタイプは異なる<emphasis>優先度</emphasis>を持ちます。デプロイメントタイプの優先度は、それらが<literal>web-beans.xml</literal>に現れる順番によって決まります。今回の例では、<literal>@Mock</literal>は<literal>@Production</literal>の後に現れるので、<literal>@Mock</literal>の方が高い優先度を持つことになります。"

#~ msgid "Whenever the manager discovers that more than one Web Bean could satisfy the contract (API type plus binding annotations) specified by an injection point, it considers the relative precedence of the Web Beans. If one has a higher precedence than the others, it chooses the higher precedence Web Bean to inject. So, in our example, the Web Bean manager will inject <literal>MockPaymentProcessor</literal> when executing in our integration testing environment (which is exactly what we want)."
#~ msgstr "マネージャは、ある注入箇所によって指定される条件（APIタイプやバインディングアノテーション）を充たしうるWeb Beanが一つより多く存在することを発見した場合、Web Beanの相対的な優先度を考慮します。もし、あるWeb Beanが他より高い優先度をもっているならば、そのWeb Beanが選択され、注入されます。今回の例では、結合テスト環境で実行する場合に、Web Beanマネージャは<literal>MockPaymentProcessor</literal>を注入することになります（これが、まさに望みどおりの動作です）。"

#~ msgid "It's interesting to compare this facility to today's popular manager architectures. Various \"lightweight\" containers also allow conditional deployment of classes that exist in the classpath, but the classes that are to be deployed must be explicity, individually, listed in configuration code or in some XML configuration file. Web Beans does support Web Bean definition and configuration via XML, but in the common case where no complex configuration is required, deployment types allow a whole set of Web Beans to be enabled with a single line of XML. Meanwhile, a developer browsing the code can easily identify what deployment scenarios the Web Bean will be used in."
#~ msgstr "このような仕組みを、最近の人気のあるマネージャのアーキテクチャと比較すると面白いでしょう。様々な、いわゆる\"軽量\"コンテナにおいて、クラスパスに存在するクラスを条件つきでデプロイすることは可能です。しかし、それらは、設定のためのコードやXMLの設定ファイルに設定を列挙することよって、あくまで明示的に、そして個別に行わなければなりません。WebnBeansでは、Web Beanの設定をXMLを通じて定義することもできますが、複雑な設定が必要ない通常の場合においては、デプロイメントタイプによってすべてのWeb Beanの集合をXML中の一行で有効にすることができます。と同時に、開発者はコードを見るだけで、簡単に、そのWeb Beanがどのシナリオにおいて使用されるのかということをつきとめることができます。"

#~ msgid "Example deployment types"
#~ msgstr "デプロイメントタイプの例"

#~ msgid "Deployment types are useful for all kinds of things, here's some examples:"
#~ msgstr "デプロイメントタイプは様々な用途に使用できます。以下に例を示します。"

#~ msgid "<literal>@AustralianTaxLaw</literal> for site-specific Web Beans"
#~ msgstr "特定のサイトに依存するWeb Beanにおける<literal>@AustralianTaxLaw</literal>の使用"

#~ msgid "<literal>@SeamFramework</literal>, <literal>@Guice</literal> for third-party frameworks which build on Web Beans"
#~ msgstr "Web Beansの上に構築されたサードパーティのフレームワークにおける<literal>@SeamFramework</literal>や<literal>@Guice</literal>の使用"

#~ msgid "<literal>@Standard</literal> for standard Web Beans defined by the Web Beans specification"
#~ msgstr "Web Beans仕様によって定義された標準Web Beanにおける<literal>@Standard</literal>の使用"

#~ msgid "I'm sure you can think of more applications..."
#~ msgstr "他にも色々な使用方法が考えられるかと思います。"

#~ msgid "It's usually easy to fix an <literal>UnsatisfiedDependencyException</literal> or <literal>AmbiguousDependencyException</literal>."
#~ msgstr "通常、<literal>UnsatisfiedDependencyException</literal>や<literal>AmbiguousDependencyException</literal>を修正することは簡単です。"

#~ msgid "To fix an <literal>UnsatisfiedDependencyException</literal>, simply provide a Web Bean which implements the API type and has the binding types of the injection point &#151; or enable the deployment type of a Web Bean that already implements the API type and has the binding types."
#~ msgstr "<literal>UnsatisfiedDependencyException</literal>を修正するには、単に、注入箇所のAPIタイプを実装し、バインディングタイプを持つようなWeb Beanを作成するか、既にAPIタイプを実装し、バインディングタイプを持ったWeb Beanのデプロイメントタイプを有効にするだけです。"

#~ msgid "To fix an <literal>AmbiguousDependencyException</literal>, introduce a binding type to distinguish between the two implementations of the API type, or change the deployment type of one of the implementations so that the Web Bean manager can use deployment type precedence to choose between them. An <literal>AmbiguousDependencyException</literal> can only occur if two Web Beans share a binding type and have exactly the same deployment type."
#~ msgstr "<literal>AmbiguousDependencyException</literal>を修正するには、APIタイプを実装する二つのWeb Beanを区別することができるバインディングタイプを導入するか、もしくは、片方のWeb Beanのデプロイメントタイプを変更し、Web Beanマネージャがデプロイメントタイプの優先度によってどちらかを選択できるようにします。<literal>AmbiguousDependencyException</literal>は、二つのWeb Beanがバインディングタイプを共有し、全く同じデプロイメントタイプを持つときにのみ、起こり得ます。"

#~ msgid "<![CDATA[@Current Manager manager;]]>"
#~ msgstr "<![CDATA[@Current Manager manager;]]>"

#~ msgid "The <literal>Manager</literal> object provides a set of methods for obtaining a Web Bean instance programatically."
#~ msgstr "<literal>Manager</literal>オブジェクトは、Web Beanインスタンスをプログラミングによって取得するための、メソッド群を提供します。"

#~ msgid "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"
#~ msgstr "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"

#~ msgid "Binding annotations may be specified by subclassing the helper class <literal>AnnotationLiteral</literal>, since it is otherwise difficult to instantiate an annotation type in Java."
#~ msgstr "バインディングアノテーションは、ヘルパークラス<literal>AnnotationLiteral</literal>をサブクラス化することによって指定します。これは、その他の方法では、Javaのアノテーションタイプをインスタンス化することは難しいからです。"

#~ msgid "If the binding type has an annotation member, we can't use an anonymous subclass of <literal>AnnotationLiteral</literal> &#151; instead we'll need to create a named subclass:"
#~ msgstr "バインディングタイプがメンバーを持っている場合には、<literal>AnnotationLiteral</literal>の無名サブクラスを使うことはできません。代わりに、名前つきのサブクラスを作成する必要がでてきます。"

#~ msgid ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"
#~ msgstr ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"

#~ msgid "Lifecycle callbacks, <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal>"
#~ msgstr "ライフサイクルコールバック、<literal>@Resource</literal>、<literal>@EJB</literal>、<literal>@PersistenceContext</literal>"

#~ msgid "Enterprise Web Beans support all the lifecycle callbacks defined by the EJB specification: <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>."
#~ msgstr "エンタープライズWeb BeanはEJB仕様で定められたすべてのライフサイクルコールバックをサポートします。<literal>@PostConstruct</literal>、<literal>@PreDestroy</literal>、<literal>@PrePassivate</literal>、<literal>@PostActivate</literal>などです。"

#~ msgid "Both enterprise and simple Web Beans support the use of <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal> for injection of Java EE resources, EJBs and JPA persistence contexts, respectively. Simple Web Beans do not support the use of <literal>@PersistenceContext(type=EXTENDED)</literal>."
#~ msgstr "エンタープライズWeb Beanも、シンプルWeb Beasも、<literal>@Resource</literal>や<literal>@EJB</literal>や<literal>@PersistenceContext</literal>を使用して、それぞれJava EEのリソース、EJB、JPAの永続化コンテキストの注入を行うことをサポートします。シンプルWeb Beanは<literal>@PersistenceContext(type=EXTENDED)</literal>の使用をサポートしません。"

#~ msgid "The <literal>@PostConstruct</literal> callback always occurs after all dependencies have been injected."
#~ msgstr "<literal>@PostConstruct</literal>コールバックは、なんらかの依存性注入が行われた後、毎回実行されます。"
