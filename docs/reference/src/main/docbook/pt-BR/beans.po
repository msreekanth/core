# Language pt-BR translations for Weld_-_JSR-299_Reference_Implementation package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: Weld_-_JSR-299_Reference_Implementation VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-12-14T13:35:16\n"
"PO-Revision-Date: 2010-04-14 15:37-0300\n"
"Last-Translator: Bruno Leonardo Gonçalves <brunolmfg@gmail.com>\n"
"Language-Team: none\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "More about beans"
msgstr "Mais sobre beans"

#. Tag: para
#, no-c-format
msgid "A bean is usually an application class that contains business logic. It may be called directly from Java code, or it may be invoked via the Unified EL. A bean may access transactional resources. Dependencies between beans are managed automatically by the container. Most beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a bean is always managed by the container."
msgstr "Um bean é usualmente uma classe de aplicação que contém lógica de negócio. Pode ser chamado diretamente a partir do código Java, ou pode ser invocado por meio da Unified EL. Um bean pode acessar recursos transacionais. As dependências entre beans são gerenciadas automaticamente pelo contêiner. A maioria dos beans são <emphasis>stateful</emphasis> e <emphasis>contextuais</emphasis>. O ciclo de vida de um bean é sempre gerenciado pelo contêiner."

#. Tag: para
#, fuzzy, no-c-format
msgid "Let&#39;s back up a second. What does it really mean to be <emphasis>contextual</emphasis>? Since beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a bean see the bean in different states. The client-visible state depends upon which instance of the bean the client has a reference to."
msgstr "Vamos voltar um segundo. O que realmente significa ser <emphasis>contextual</emphasis>? Uma vez que os beans podem ser stateful, é importante saber <emphasis>qual</emphasis> instância do bean eu tenho. Ao contrário de um modelo de componentes stateless (por exemplo, stateless session beans) ou um modelo de componentes singleton (como servlets, ou singleton beans), diferentes clientes de um bean vêem o bean em diferentes estados. O estado visível ao cliente depende de para qual instância do bean o cliente tem uma referência."

#. Tag: para
#, no-c-format
msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the bean determines:"
msgstr "No entanto, como em um modelo stateless ou singleton, mas de modo <emphasis>diferente</emphasis> em stateful session beans, o cliente não controla o ciclo de vida da instância pela explícita criação e destruição dela. Em vez disso, o <emphasis>escopo</emphasis> do bean determina:"

#. Tag: para
#, no-c-format
msgid "the lifecycle of each instance of the bean and"
msgstr "o ciclo de vida de cada instância do bean e"

#. Tag: para
#, no-c-format
msgid "which clients share a reference to a particular instance of the bean."
msgstr "quais clientes compartilham uma referência para uma instância específica do bean."

#. Tag: para
#, no-c-format
msgid "For a given thread in a CDI application, there may be an <emphasis>active context</emphasis> associated with the scope of the bean. This context may be unique to the thread (for example, if the bean is request scoped), or it may be shared with certain other threads (for example, if the bean is session scoped) or even all other threads (if it is application scoped)."
msgstr "Para uma dada thread em uma aplicação CDI, pode haver um <emphasis>contexto ativo</emphasis> associado com o escopo do bean. Este contexto pode ser único para a thread (por exemplo, se o bean possui escopo de solicitação), ou pode ser compartilhado com algumas outras threads (por exemplo, se o bean possui escopo de sessão) ou mesmo com todas as outras threads (se ele possui escopo de aplicação)."

#. Tag: para
#, no-c-format
msgid "Clients (for example, other beans) executing in the same context will see the same instance of the bean. But clients in a different context may see a different instance (depending on the relationship between the contexts)."
msgstr "Os clientes (por exemplo, outros beans) executados no mesmo contexto verão a mesma instância do bean. Mas os clientes em um diferente contexto podem ver uma instância diferente (dependendo do relacionamento entre os contextos)."

#. Tag: para
#, fuzzy, no-c-format
msgid "One great advantage of the contextual model is that it allows stateful beans to be treated like services! The client need not concern itself with managing the lifecycle of the bean it&#39;s using, <emphasis>nor does it even need to know what that lifecycle is.</emphasis> Beans interact by passing messages, and the bean implementations define the lifecycle of their own state. The beans are loosely coupled because:"
msgstr "Uma grande vantagem do modelo contextual é que ele permite que stateful beans sejam tratados como serviços!  O cliente não precisa se preocupar com o gerenciamento do ciclo de vida do bean que ele está usando, <emphasis>nem mesmo precisam saber o que é ciclo de vida.</emphasis> Os beans interagem passando mensagens, e as implementações do bean definem o ciclo de vida de seu próprio estado. Os beans são de baixo acoplamento porque:"

#. Tag: para
#, no-c-format
msgid "they interact via well-defined public APIs"
msgstr "eles interagem por meio de APIs bem definidas e públicas"

#. Tag: para
#, no-c-format
msgid "their lifecycles are completely decoupled"
msgstr "seus ciclos de vida são completamente desacoplados"

#. Tag: para
#, fuzzy, no-c-format
msgid "We can replace one bean with another different bean that implements the same interface and has a different lifecycle (a different scope) without affecting the other bean implementation. In fact, CDI defines a simple facility for overriding bean implementations at deployment time, as we will see in <xref linkend=\"alternatives\" />."
msgstr "Podemos substituir um bean por outro bean diferente que implementa a mesma interface e tem um ciclo de vida diferente (um escopo diferente) sem afetar a outra implementação do bean. Na verdade, CDI define um mecanismo simples para sobrepor implementações de bean em tempo de implantação, como veremos na <xref linkend=\"alternatives\" />."

#. Tag: para
#, fuzzy, no-c-format
msgid "Note that not all clients of a bean are beans themselves. Other objects such as servlets or message-driven beans—which are by nature not injectable, contextual objects—may also obtain references to beans by injection."
msgstr "Note que nem todos os clientes de um bean são eles próprios também beans. Outros objetos como servlets ou message-driven beans—que são por natureza objetos não injetáveis e não contextuais—podem também obter referências para beans por meio de injeção."

#. Tag: title
#, no-c-format
msgid "The anatomy of a bean"
msgstr "A anatomia de um bean"

#. Tag: para
#, no-c-format
msgid "Enough hand-waving. More formally, the anatomy of a bean, according to the spec:"
msgstr "Já chega de acenar as mãos. Mais formalmente, a anatomia de um bean, de acordo com a especificação:"

#. Tag: para
#, no-c-format
msgid "A bean comprises the following attributes:"
msgstr "Um bean abrange os seguintes atributos:"

#. Tag: para
#, no-c-format
msgid "A (nonempty) set of bean types"
msgstr "Um conjunto (não vazio) de tipos de bean"

#. Tag: para
#, no-c-format
msgid "A (nonempty) set of qualifiers"
msgstr "Um conjunto (não vazio) de qualificadores"

#. Tag: para
#, no-c-format
msgid "A scope"
msgstr "Um escopo"

#. Tag: para
#, no-c-format
msgid "Optionally, a bean EL name"
msgstr "Opcionalmente, um nome EL do bean"

#. Tag: para
#, no-c-format
msgid "A set of interceptor bindings"
msgstr "Um conjunto de vinculações com interceptadores"

#. Tag: para
#, no-c-format
msgid "A bean implementation"
msgstr "Uma implementação do bean"

#. Tag: para
#, no-c-format
msgid "Furthermore, a bean may or may not be an alternative."
msgstr "Além disso, um bean pode ou não pode ser um bean alternativo."

#. Tag: para
#, fuzzy, no-c-format
msgid "Let&#39;s see what all this new terminology means."
msgstr "Vamos ver o que toda esta nova terminologia significa."

#. Tag: title
#, no-c-format
msgid "Bean types, qualifiers and dependency injection"
msgstr "Tipos e qualificadores de bean e injeção de dependência"

#. Tag: para
#, fuzzy, no-c-format
msgid "Beans usually acquire references to other beans via dependency injection. Any injected attribute specifies a &#34;contract&#34; that must be satisfied by the bean to be injected. The contract is:"
msgstr "Beans usualmente adquirem referências para outros beans por meio de injeção de dependência. Qualquer atributo injetado especifica um \"contrato\" que deve ser satisfeito pelo bean para ser injetado. O contrato é:"

#. Tag: para
#, no-c-format
msgid "a bean type, together with"
msgstr "um tipo de bean, juntamente com"

#. Tag: para
#, no-c-format
msgid "a set of qualifiers."
msgstr "um conjunto de qualificadores."

#. Tag: para
#, no-c-format
msgid "A bean type is a user-defined class or interface; a type that is client-visible. If the bean is an EJB session bean, the bean type is the <literal>@Local</literal> interface or bean-class local view. A bean may have multiple bean types. For example, the following bean has four bean types:"
msgstr "Um tipo de bean é uma classe ou interface definida pelo usuário; um tipo que é visível ao cliente. Se o bean é um EJB session bean, o tipo do bean é a interface <literal>@Local</literal> ou a classe do bean da visão local. Um bean pode possuir múltiplos tipos. Por exemplo, o seguinte bean possui quatro tipos de bean:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class BookShop \n"
"      extends Business \n"
"      implements Shop&#60;Book&#62; {\n"
"   ...\n"
"}"
msgstr ""
"<![CDATA[public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "The bean types are <literal>BookShop</literal>, <literal>Business</literal> and <literal>Shop&#60;Book&#62;</literal>, as well as the implicit type <literal>java.lang.Object</literal>. (Notice that a parameterized type is a legal bean type)."
msgstr "Os tipos de bean são <literal>BookShop</literal>, <literal>Business</literal> e <literal>Shop&lt;Book&gt;</literal>, bem como o tipo implícito <literal>java.lang.Object</literal>. (Observe que um tipo parametrizado é um tipo de bean válido)."

#. Tag: para
#, no-c-format
msgid "Meanwhile, this session bean has only the local interfaces <literal>BookShop</literal>, <literal>Auditable</literal> and <literal>java.lang.Object</literal> as bean types, since the bean class, <literal>BookShopBean</literal> is not a client-visible type."
msgstr "Entretanto, este session bean possui somente as interfaces locais <literal>BookShop</literal>, <literal>Auditable</literal> e <literal>java.lang.Object</literal> como tipos de bean, uma vez que a classe do bean, <literal>BookShopBean</literal>, não é um tipo visível ao cliente."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Stateful\n"
"public class BookShopBean \n"
"      extends Business \n"
"      implements BookShop, Auditable {\n"
"   ...\n"
"}"
msgstr ""
"<![CDATA[@Stateful\n"
"public class BookShopBean \n"
"      extends Business \n"
"      implements BookShop, Auditable {\n"
"   ...\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "The bean types of a session bean include local interfaces and the bean class local view (if any). EJB remote interfaces are not considered bean types of a session bean. You can&#39;t inject an EJB using its remote interface unless you define a <emphasis>resource</emphasis>, which we&#39;ll meet in <xref linkend=\"resources\" />."
msgstr "Os tipos de bean de um session bean incluem suas interfaces locais e a classe de visão local do bean (se houver). As interfaces remotas do EJB não são consideradas tipos de bean de um session bean. Você não pode injetar um EJB usando sua interface remota, a menos que você defina um <emphasis>recurso</emphasis>, o qual vamos abordar no <xref linkend=\"resources\" />."

#. Tag: para
#, fuzzy, no-c-format
msgid "Bean types may be restricted to an explicit set by annotating the bean with the <literal>@Typed</literal> annotation and listing the classes that should be bean types. For instance, the bean types of this bean have been restricted to <literal>Shop&#60;Book&#62;</literal>, together with <literal>java.lang.Object</literal>:"
msgstr "Os tipos do bean podem ser limitados a um conjunto explícito, anotando o bean com a anotação <literal>@Typed</literal> e listando as classes que devem ser os tipos do bean. Por exemplo, os tipos de bean desde bean foram restritos a <literal>Shop&lt;Book&gt;</literal>, juntamente com <literal>java.lang.Object</literal>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Typed(Shop.class)\n"
"public class BookShop \n"
"      extends Business \n"
"      implements Shop&#60;Book&#62; {\n"
"   ...\n"
"}"
msgstr ""
"<![CDATA[@Typed(Shop.class)\n"
"public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Sometimes, a bean type alone does not provide enough information for the container to know which bean to inject. For instance, suppose we have two implementations of the <literal>PaymentProcessor</literal> interface: <literal>CreditCardPaymentProcessor</literal> and <literal>DebitPaymentProcessor</literal>. Injecting a field of type <literal>PaymentProcessor</literal> introduces an ambiguous condition. In these cases, the client must specify some additional quality of the implementation it is interested in. We model this kind of &#34;quality&#34; using a qualifier."
msgstr "Algumas vezes um tipo de bean sozinho não fornece informação suficiente para o contêiner saber qual bean injetar. Por exemplo, suponha que temos duas implementações da interface <literal>PaymentProcessor</literal>: <literal>CreditCardPaymentProcessor</literal> e <literal>DebitPaymentProcessor</literal>. Injetar em um campo do tipo <literal>PaymentProcessor</literal> introduz uma condição ambígua. Nestes casos, o cliente deve especificar algum qualidade adicional da implementação que ele está interessado. Modelamos esta categoria de \"qualidade\" usando um qualificador."

#. Tag: para
#, fuzzy, no-c-format
msgid "A qualifier is a user-defined annotation that is itself annotated <literal>@Qualifer</literal>. A qualifier annotation is an extension of the type system. It lets us disambiguate a type without having to fall back to string-based names. Here&#39;s an example of a qualifier annotation:"
msgstr "Um qualificador é uma anotação definida pelo usuário que é ela própria anotada com <literal>@Qualifer</literal>. Uma anotação de qualificador é uma extensão do sitema de tipos. Ela nos permite desambiguar um tipo sem ter que recorrer a nomes baseados em strings. Aqui está um exemplo de uma anotação de qualificador:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Target({TYPE, METHOD, PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface CreditCard {}"
msgstr ""
"<![CDATA[@Qualifier\n"
"@Target({TYPE, METHOD, PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface CreditCard {}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "You may not be used to seeing the definition of an annotation. In fact, this might be the first time you&#39;ve encountered one. With CDI, annotation definitions will become a familiar artifact as you&#39;ll be creating them from time to time."
msgstr "Você pode não estar acostumado a ver a definição de uma anotação. Na verdade, essa poderia ser a primeira vez que você encontrou uma. Com CDI, definições de anotação se tornará um artefato familiar conforme você for criando-os de vez em quando."

#. Tag: para
#, fuzzy, no-c-format
msgid "Pay attention to the names of the built-in annotations in CDI and EJB. You&#39;ll notice that they are often adjectives. We encourage you to follow this convention when creating your custom annotations, since they serve to describe the behaviors and roles of the class."
msgstr "Preste atenção nos nomes das anotações embutidas em CDI e EJB. Você perceberá que elas são muitas vezes adjetivos. Nós encorajamos você a seguir esta convenção ao criar suas próprias anotações, uma vez que elas servem para descrever os comportamentos e papéis da classe."

#. Tag: para
#, no-c-format
msgid "Now that we have defined a qualifier annotation, we can use it to disambiguate an injection point. The following injection point has the bean type <literal>PaymentProcessor</literal> and qualifier <literal>@CreditCard</literal>:"
msgstr "Agora que temos definido uma anotação de qualificador, podemos utilizá-la para resolver a ambiguidade no ponto de injeção. O seguinte ponto de injeção possui o tipo de bean <literal>PaymentProcessor</literal> e o qualificador <literal>@CreditCard</literal>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @CreditCard PaymentProcessor paymentProcessor"
msgstr "<![CDATA[@Inject @CreditCard PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "If an injection point does not explicitly specify a qualifier, it has the default qualifier, <literal>@Default</literal>."
msgstr "Se um ponto de injeção não define explicitamente um qualificador, ele terá o qualificador padrão, <literal>@Default</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "For each injection point, the container searches for a bean which satisfies the contract, one which has the bean type and all the qualifiers. If it finds exactly one matching bean, it injects an instance of that bean. If it doesn&#39;t, it reports an error to the user."
msgstr "Para cada ponto de injeção, o contêiner pesquisa por um bean que satisfaça o contrato, um que tenha o tipo de bean e todos os qualificadores. Se ele encontrar exatamente um bean, ele injeta uma instância deste bean. Se ele não encontrar, ele reporta um erro ao usuário."

#. Tag: para
#, no-c-format
msgid "How do we specify that qualifiers of a bean? By annotating the bean class, of course! The following bean has the qualifier <literal>@CreditCard</literal> and implements the bean type <literal>PaymentProcessor</literal>. Therefore, it satisfies our qualified injection point:"
msgstr "Como especificamos os qualificadores de um bean? Anotando a classe de bean, é claro! O seguinte bean possui o qualificador <literal>@CreditCard</literal> e implementa o tipo de bean <literal>PaymentProcessor</literal>. Portanto, ele satisfaz nosso ponto de injeção qualificado:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }"
msgstr ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"

#. Tag: para
#, no-c-format
msgid "If a bean does not explicitly specify a qualifier, it has the default qualifier, <literal>@Default</literal>."
msgstr "Se um bean não define explicitamente um qualificador, ele terá o qualificador padrão, <literal>@Default</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "That&#39;s not quite the end of the story. CDI also defines a simple <emphasis>resolution rule</emphasis> that helps the container decide what to do if there is more than one bean that satisfies a particular contract. We&#39;ll get into the details in <xref linkend=\"injection\" />."
msgstr "Esse não é bem o fim da história. CDI também define uma simples <emphasis>regra de resolução</emphasis> que ajuda o contêiner decidir o que fazer se houver mais de um bean que satisfaz um contrato específico. Vamos entrar em mais detalhes no <xref linkend=\"injection\" />."

#. Tag: title
#, no-c-format
msgid "Scope"
msgstr "Escopo"

#. Tag: para
#, no-c-format
msgid "The <emphasis>scope</emphasis> of a bean defines the lifecycle and visibility of its instances. The CDI context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built into the specification, and provided by the container. Each scope is represented by an annotation type."
msgstr "O <emphasis>escopo</emphasis> de um bean define o ciclo de vida e a visibilidade de suas instâncias. O modelo de contexto da CDI é extensível, acomodando escopos arbitrários. No entanto, certos escopos importantes estão encorporados na especificação, e fornecidos pelo contêiner. Cada escopo é representado por um tipo de anotação."

#. Tag: para
#, no-c-format
msgid "For example, any web application may have <emphasis>session scoped</emphasis> bean:"
msgstr "Por exemplo, qualquer aplicação web pode possuir beans com <emphasis>escopo de sessão</emphasis>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @SessionScoped\n"
"class ShoppingCart implements Serializable { ... }"
msgstr ""
"<![CDATA[public @SessionScoped\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#, no-c-format
msgid "An instance of a session-scoped bean is bound to a user session and is shared by all requests that execute in the context of that session."
msgstr "Uma instância de um bean com escopo de sessão está vinculada à sessão do usuário e é compartilhada por todas as solicitações executadas no contexto desta sessão."

#. Tag: para
#, fuzzy, no-c-format
msgid "Keep in mind that once a bean is bound to a context, it remains in that context until the context is destroyed. There is no way to manually remove a bean from a context. If you don&#39;t want the bean to sit in the session indefinitely, consider using another scope with a shorted lifespan, such as the request or conversation scope."
msgstr "Mantenha em mente que uma vez que um bean está vinculado a um contexto, ele permanece neste contexto até que o contexto seja destruído. Não existe modo algum para remover manualmente um bean daquele contexto. Se você não quer que o bean fique na sessão indefinitivamente, considere o uso de um outro escopo com um tempo de vida mais curto, como os escopos de solicitação e conversação."

#. Tag: para
#, no-c-format
msgid "If a scope is not explicitly specified, then the bean belongs to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Beans with this scope live to serve the object into which they were injected, which means their lifecycle is bound to the lifecycle of that object."
msgstr "Se um escopo não está explicitamente especificado, então o bean pertence a um escopo especial chamado de <emphasis>pseudo-escopo dependente</emphasis>. Os beans com este escopo vivem para servir o objeto no qual eles foram injetados, o que significa que seu ciclo de vida está vinculado ao ciclo de vida deste objeto."

#. Tag: para
#, fuzzy, no-c-format
msgid "We&#39;ll talk more about scopes in <xref linkend=\"scopescontexts\" />."
msgstr "Nós falaremos mais sobre escopos no <xref linkend=\"scopescontexts\" />."

#. Tag: title
#, no-c-format
msgid "EL name"
msgstr "Nome EL"

#. Tag: para
#, no-c-format
msgid "If you want to reference a bean in non-Java code that supports Unified EL expressions, for example, in a JSP or JSF page, you must assign the bean an <emphasis>EL name</emphasis>."
msgstr "Se você quer referenciar um bean em um código não-Java que suporta expressões Unified EL, por exemplo, em uma página JSP ou JSF, você deve assinar o bean com um <emphasis>nome EL</emphasis>."

#. Tag: para
#, no-c-format
msgid "The EL name is specified using the <literal>@Named</literal> annotation, as shown here:"
msgstr "O nome EL é especificado usando a anotação <literal>@Named</literal>, como mostrado aqui:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @SessionScoped @Named(&#34;cart&#34;)\n"
"class ShoppingCart implements Serializable { ... }"
msgstr ""
"<![CDATA[public @SessionScoped @Named(\"cart\")\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#, no-c-format
msgid "Now we can easily use the bean in any JSF or JSP page:"
msgstr "Agora podemos facilmente usar o bean em qualquer página JSF ou JSP:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"&#60;h:dataTable value=&#34;#{cart.lineItems}&#34; var=&#34;item&#34;&#62;\n"
"   ...\n"
"&#60;/h:dataTable&#62;"
msgstr ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"   ...\n"
"</h:dataTable>]]>"

#. Tag: para
#, no-c-format
msgid "The <literal>@Named</literal> annotation is not what makes the class a bean. Most classes in a bean archive are already recognized as beans. The <literal>@Named</literal> annotation just makes it possible to reference the bean from the EL, most commonly from a JSF view."
msgstr "A anotação <literal>@Named</literal> não é o que torna a classe um bean. A maioria das classes em um arquivo de beans já são reconhecidas como beans. A anotação <literal>@Named</literal> apenas torna possível referenciar o bean a partir da EL, mais comumente a partir de uma visão JSF."

#. Tag: para
#, no-c-format
msgid "We can let CDI choose a name for us by leaving off the value of the <literal>@Named</literal> annotation:"
msgstr "Nós podemos deixar o CDI escolher um nome para nós, deixando de fora o valor da anotação <literal>@Named</literal>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @SessionScoped @Named\n"
"class ShoppingCart implements Serializable { ... }"
msgstr ""
"<![CDATA[public @SessionScoped @Named\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#, no-c-format
msgid "The name defaults to the unqualified class name, decapitalized; in this case, <literal>shoppingCart</literal>."
msgstr "O nome padrão vem do nome não-qualificado da classe, descapitalizado; neste caso, <literal>shoppingCart</literal>."

#. Tag: title
#, no-c-format
msgid "Alternatives"
msgstr "Alternativos"

#. Tag: para
#, fuzzy, no-c-format
msgid "We&#39;ve already seen how qualifiers let us choose between multiple implementations of an interface at development time. But sometimes we have an interface (or other bean type) whose implementation varies depending upon the deployment environment. For example, we may want to use a mock implementation in a testing environment. An <emphasis>alternative</emphasis> may be declared by annotating the bean class with the <literal>@Alternative</literal> annotation."
msgstr "Nós já vimos como os qualificadores nos permite escolher entre múltiplas implementações de uma interface durante o desenvolvimento. Mas algumas vezes temos uma interface (ou outro tipo de bean), cuja implementação varia dependendo do ambiente de implantação. Por exemplo, podemos querer usar uma implementação de imitação em um ambiente de teste. Uma <emphasis>alternativa</emphasis> seria declarar a classe de bean com a anotação <literal>@Alternative</literal>."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @Alternative\n"
"class MockPaymentProcessor extends PaymentProcessorImpl { ... }"
msgstr ""
"<![CDATA[public @Alternative\n"
"class MockPaymentProcessor extends PaymentProcessorImpl { ... }]]>"

#. Tag: para
#, no-c-format
msgid "We normally annotate a bean <literal>@Alternative</literal> only when there is some other implementation of an interface it implements (or of any of its bean types). We can choose between alternatives at deployment time by <emphasis>selecting</emphasis> an alternative in the CDI deployment descriptor <literal>META-INF/beans.xml</literal> of the jar or Java EE module that uses it. Different modules can specify that they use different alternatives."
msgstr "Normalmente anotamos um bean com <literal>@Alternative</literal> somente quando existe alguma outra implementação de uma interface que ele implementa (ou de qualquer de seus tipos de bean). Podemos escolher entre as alternativas no momento da implantação <emphasis>selecionando</emphasis> uma alternativa no descritor de implantação do CDI <literal>META-INF/beans.xml</literal> dentro do jar ou módulo Java EE que utiliza-o. Diferentes módulos podem especificar que eles usam diferentes alternativos."

#. Tag: para
#, fuzzy, no-c-format
msgid "We cover alternatives in more detail in <xref linkend=\"alternatives\" />."
msgstr "Nós cobriremos os alternativos em mais detalhes na <xref linkend=\"alternatives\" />."

#. Tag: title
#, no-c-format
msgid "Interceptor binding types"
msgstr "Tipos para vinculação de interceptador"

#. Tag: para
#, fuzzy, no-c-format
msgid "You might be familiar with the use of interceptors in EJB 3.0. In Java EE 6, this functionality has been generalized to work with other managed beans. That&#39;s right, you no longer have to make your bean an EJB just to intercept its methods. Holler. So what does CDI have to offer above and beyond that? Well, quite a lot actually. Let&#39;s cover some background."
msgstr "Você pode estar familiarizado com o uso de interceptadores em EJB 3.0. Em Java EE 6, esta funcionalidade foi generalizada para trabalhar com outros beans gerenciados. Está bem, você não precisa tornar seu bean um EJB apenas para interceptar seus métodos. (Berro). Então, o que CDI tem a oferecer além disso? Bem, bastante realmente. Vamos dar algumas explicações."

#. Tag: para
#, fuzzy, no-c-format
msgid "The way that interceptors were defined in Java EE 5 was counter-intuitive. You were required to specify the <emphasis>implementation</emphasis> of the interceptor directly on the <emphasis>implementation</emphasis> of the EJB, either in the <literal>@Interceptors</literal> annotation or in the XML descriptor. You might as well just put the interceptor code <emphasis>in</emphasis> the implementation! Second, the order in which the interceptors are applied is taken from the order in which they are declared in the annotation or the XML descriptor. Perhaps this isn&#39;t so bad if you&#39;re applying the interceptors to a single bean. But, if you are applying them repeatedly, then there&#39;s a good chance that you&#39;ll inadvertently define a different order for different beans. Now that&#39;s a problem."
msgstr "A maneira em que interceptadores foram definidos em Java EE 5 não foi muito intuitivo. Era necessário especificar a <emphasis>implementação</emphasis> do interceptador diretamente na <emphasis>implementação</emphasis> do EJB, seja pela anotação <literal>@Interceptors</literal> ou no descritor XML. Você pode muito bem apenas colocar o código do interceptador <emphasis>dentro</emphasis> da implementação! Em segundo lugar, a ordem na qual os interceptadores são aplicados é obtida a partir da ordem na qual eles são declarados na anotação ou no descritor XML. Talvez isto não seja tão ruim se você está aplicando os interceptadores a um único bean. Mas, se você está aplicando eles repetidamente, então há uma boa chance de você definir por descuido uma ordem diferente para diferentes beans. Agora isso é um problema."

#. Tag: para
#, no-c-format
msgid "CDI provides a new approach to binding interceptors to beans that introduces a level of indirection (and thus control). We must define an <emphasis>interceptor binding type</emphasis> to describe the behavior implemented by the interceptor."
msgstr "CDI fornece uma nova abordagem para vincular interceptadores a beans que introduz um nível de indirecionamento (e, portanto, de controle). Nós temos que definir um <emphasis>tipo para vinculação de interceptador</emphasis> que descreve o comportamento implementado pelo interceptador."

#. Tag: para
#, no-c-format
msgid "An interceptor binding type is a user-defined annotation that is itself annotated <literal>@InterceptorBinding</literal>. It lets us bind interceptor classes to bean classes with no direct dependency between the two classes."
msgstr "Um tipo para vinculação de interceptador é uma anotação definida pelo usuário que é ela mesma anotada com <literal>@InterceptorBinding</literal>. Isto nos permite vincular as classes de interceptador a classes de bean com nenhuma dependência direta entre as duas classes."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@InterceptorBinding\n"
"@Inherited\n"
"@Target( { TYPE, METHOD })\n"
"@Retention(RUNTIME)\n"
"public @interface Transactional {}"
msgstr ""
"<![CDATA[@InterceptorBinding\n"
"@Inherited\n"
"@Target( { TYPE, METHOD })\n"
"@Retention(RUNTIME)\n"
"public @interface Transactional {}]]>"

#. Tag: para
#, no-c-format
msgid "The interceptor that implements transaction management declares this annotation:"
msgstr "O interceptador que implementa o gerenciamento de transação declara esta anotação:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @Transactional @Interceptor\n"
"class TransactionInterceptor { ... }"
msgstr ""
"<![CDATA[public @Transactional @Interceptor\n"
"class TransactionInterceptor { ... }]]>"

#. Tag: para
#, no-c-format
msgid "We can apply the interceptor to a bean by annotating the bean class with the same interceptor binding type:"
msgstr "Podemos aplicar o interceptador em um bean anotando a classe de bean com o mesmo tipo para vinculação de interceptador."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public @SessionScoped @Transactional\n"
"class ShoppingCart implements Serializable { ... }"
msgstr ""
"<![CDATA[public @SessionScoped @Transactional\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Notice that <literal>ShoppingCart</literal> and <literal>TransactionInterceptor</literal> don&#39;t know anything about each other."
msgstr "Observe que <literal>ShoppingCart</literal> e <literal>TransactionInterceptor</literal> não sabem nada sobre o outro."

#. Tag: para
#, fuzzy, no-c-format
msgid "Interceptors are deployment-specific. (We don&#39;t need a <literal>TransactionInterceptor</literal> in our unit tests!) By default, an interceptor is disabled. We can enable an interceptor using the CDI deployment descriptor <literal>META-INF/beans.xml</literal> of the jar or Java EE module. This is also where we specify the interceptor ordering."
msgstr "Interceptadores são específicos de implantação. (Não precisamos de um <literal>TransactionInterceptor</literal> em nossos testes de unidade!) Por padrão, um interceptador está disabilitado. Podemos habilitar um interceptador usando o descritor de implantação CDI <literal>META-INF/beans.xml</literal> do jar ou módulo Java EE. Este descritor também é onde especificamos a ordem dos interceptadores."

#. Tag: para
#, fuzzy, no-c-format
msgid "We&#39;ll discuss interceptors, and their cousins, decorators, in <xref linkend=\"interceptors\" /> and <xref linkend=\"decorators\" />."
msgstr "Discutiremos sobre interceptadores, e seus primos decoradores, no <xref linkend=\"interceptors\" /> e <xref linkend=\"decorators\" />."

#. Tag: title
#, no-c-format
msgid "What kinds of classes are beans?"
msgstr "Quais categorias de classes são beans?"

#. Tag: para
#, fuzzy, no-c-format
msgid "We&#39;ve already seen two types of beans: JavaBeans and EJB session beans. Is that the whole story? Actually, it&#39;s just the beginning. Let&#39;s explore the various kinds of beans that CDI implementations must support out-of-the-box."
msgstr "Nós já vimos dois tipos de beans: JavaBeans e EJB session beans. Esta é toda a história? Na verdade, é apenas o começo. Vamos explorar as várias categorias de beans que implementações CDI devem suportar sem modificações."

#. Tag: title
#, no-c-format
msgid "Managed beans"
msgstr "Managed beans"

#. Tag: para
#, fuzzy, no-c-format
msgid "A managed bean is a Java class. The basic lifecycle and semantics of a managed bean are defined by the Managed Beans specification. You can explicitly declare a managed bean by annotating the bean class <literal>@ManagedBean</literal>, but in CDI you don&#39;t need to. According to the specification, the CDI container treats any class that satisfies the following conditions as a managed bean:"
msgstr "Um managed bean é uma classe Java. O ciclo de vida básico e a semântica de um managed bean são definidos pelo especificação de Managed Beans. Você pode explicitamente declarar um managed bean anotando a classe do bean com <literal>@ManagedBean</literal>, mas em CDI você não precisa disto. De acordo com a especificação, o contêiner CDI trata qualquer classe que satisfaz as seguintes condições como um managed bean:"

#. Tag: para
#, no-c-format
msgid "It is not a non-static inner class."
msgstr "Ela não é uma classe interna não-estática."

#. Tag: para
#, no-c-format
msgid "It is a concrete class, or is annotated <literal>@Decorator</literal>."
msgstr "Ela é uma classe concreta, ou é anotada com <literal>@Decorator</literal>."

#. Tag: para
#, no-c-format
msgid "It is not annotated with an EJB component-defining annotation or declared as an EJB bean class in <literal>ejb-jar.xml</literal>."
msgstr "Ela não é anotada com uma anotação de definição de componente EJB ou declarada como classe de bean em <literal>ejb-jar.xml</literal>."

#. Tag: para
#, no-c-format
msgid "It does not implement <literal>javax.enterprise.inject.spi.Extension</literal>."
msgstr "Ela não implementa <literal>javax.enterprise.inject.spi.Extension</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "It has an appropriate constructor—either:"
msgstr "Ela tem um construtor apropriado—ou seja:"

#. Tag: para
#, no-c-format
msgid "the class has a constructor with no parameters, or"
msgstr "a classe possui um construtor sem parâmetros, ou"

#. Tag: para
#, no-c-format
msgid "the class declares a constructor annotated <literal>@Inject</literal>."
msgstr "a classe declara um construtor anotado com <literal>@Inject</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "According to this definition, JPA entities are technically managed beans. However, entities have their own special lifecycle, state and identity model and are usually instantiated by JPA or using <literal>new</literal>. Therefore we don&#39;t recommend directly injecting an entity class. We especially recommend against assigning a scope other than <literal>@Dependent</literal> to an entity class, since JPA is not able to persist injected CDI proxies."
msgstr "De acordo com esta definição, entidades JPA são tecnicamente managed beans. No entanto, as entidades possuem ciclo de vida, estado e modelo de identidade próprios e especiais, e são usualmente instanciadas por JPA ou utilizando <literal>new</literal>. Portanto, não recomendamos injetar uma classe de entidade diretamente. Recomendamos especialmente não atribuir um escopo que não seja <literal>@Dependent</literal> em uma classe de entidade, uma vez que JPA não é capaz de persistir proxies injetados por CDI."

#. Tag: para
#, no-c-format
msgid "The unrestricted set of bean types for a managed bean contains the bean class, every superclass and all interfaces it implements directly or indirectly."
msgstr "O conjunto de restrições de tipos de bean para um managed bean contém a classe do bean, qualquer superclasse e todas as interfaces que ele implementa diretamente ou indiretamente."

#. Tag: para
#, no-c-format
msgid "If a managed bean has a public field, it must have the default scope <literal>@Dependent</literal>."
msgstr "Se um managed bean possui um campo público, ele deve ter o escopo padrão <literal>@Dependent</literal>."

#. Tag: para
#, no-c-format
msgid "Managed beans support the <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal> lifecycle callbacks."
msgstr "Managed beans suportam as chamadas <literal>@PostConstruct</literal> e <literal>@PreDestroy</literal> de seu ciclo de vida."

#. Tag: para
#, no-c-format
msgid "Session beans are also, technically, managed beans. However, since they have their own special lifecycle and take advantage of additional enterprise services, the CDI specification considers them to be a different kind of bean."
msgstr "Session beans também são, tecnicamente, managed beans. No entanto, uma vez que eles possuem seu próprio e específico ciclo de vida e tiram vantagem de serviços corporativos adicionais, a especificação CDI considera que eles fazem parte de uma categoria diferente de beans."

#. Tag: title
#, no-c-format
msgid "Session beans"
msgstr "Session beans"

#. Tag: para
#, no-c-format
msgid "Session beans belong to the EJB specification. They have a special lifecycle, state management and concurrency model that is different to other managed beans and non-managed Java objects. But session beans participate in CDI just like any other bean. You can inject one session bean into another session bean, a managed bean into a session bean, a session bean into a managed bean, have a managed bean observe an event raised by a session bean, and so on."
msgstr "Session beans pertencem à especificação EJB. Eles possuem um ciclo de vida específico, gerenciamento de estado e o modelo de concorrência é diferente de outros beans geernciados e objetos Java não-gerenciados. Mas session beans participam em CDI apenas como qualquer outro bean. Você pode injetar um session bean dentro de outro session bean, um managed bean dentro de um session bean, um session bean dentro de um managed bean, ter um managed bean observando um evento disparado por um session bean, e assim por diante."

#. Tag: para
#, no-c-format
msgid "Message-driven and entity beans are by nature non-contextual objects and may not be injected into other objects. However, message-driven beans can take advantage of some CDI functionality, such as dependency injection, interceptors and decorators. In fact, CDI will perform injection into any session or message-driven bean, even those which are not contextual instances."
msgstr "Os massage-driven beans e entity beans são por natureza objetos não-contextuais e não podem ser injetados dentro de outros objetos. No entanto, message-driven beans podem tirar vantagem de algumas funcionadades CDI, como injeção de dependência, interceptadores e decoradores. Na verdade, CDI realizará injeção dentro de qualquer session bean ou message-driven bean, mesmo aqueles que não são instâncias contextuais."

#. Tag: para
#, no-c-format
msgid "The unrestricted set of bean types for a session bean contains all local interfaces of the bean and their superinterfaces. If the session bean has a bean class local view, the unrestricted set of bean types contains the bean class and all superclasses. In addition, <literal>java.lang.Object</literal> is a bean type of every session bean. But remote interfaces are <emphasis>not</emphasis> included in the set of bean types."
msgstr "O conjunto irrestrito de tipos de bean para um session bean contém todas as interfaces locais do bean e suas superinterfaces. Se o session bean possui uma classe de bean de visão local, o conjunto irrestrito de tipos de bean contém a classe de bean e todas as superclasses. Além disso, <literal>java.lang.Object</literal> é um tipo de bean de todo session bean. Porém, interfaces remotas <emphasis>não</emphasis> são incluídas no conjunto de tipos de bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "There&#39;s no reason to explicitly declare the scope of a stateless session bean or singleton session bean. The EJB container controls the lifecycle of these beans, according to the semantics of the <literal>@Stateless</literal> or <literal>@Singleton</literal> declaration. On the other hand, a stateful session bean may have any scope."
msgstr "Não existe razão alguma para declarar explicitamente o escopo de um stateless session bean ou singleton session bean. O contêiner EJB controla o ciclo de vida destes beans, de acordo com a semântica da declaração <literal>@Stateless</literal> ou <literal>@Singleton</literal>. Por outro lado, um stateful session bean pode possuir qualquer escopo."

#. Tag: para
#, fuzzy, no-c-format
msgid "Stateful session beans may define a <emphasis>remove method</emphasis>, annotated <literal>@Remove</literal>, that is used by the application to indicate that an instance should be destroyed. However, for a contextual instance of the bean—an instance under the control of CDI—this method may only be called by the application if the bean has scope <literal>@Dependent</literal>. For beans with other scopes, the application must let the container destroy the bean."
msgstr "Stateful session beans podem definir um <emphasis>método de remoção</emphasis>, anotado com <literal>@Remove</literal>, que é utilizado pela aplicação para indicar que uma instância deve ser destruída. No entato, para uma instância contextual do bean—uma instância sob o controle de CDI—este método só pode ser chamado pela aplicação se o bean possuir o escopo <literal>@Dependent</literal>. Para beans com outros escopos, a aplicação deve deixar o contêiner destruir o bean."

#. Tag: para
#, no-c-format
msgid "So, when should we use a session bean instead of a plain managed bean? Whenever we need the advanced enterprise services offered by EJB, such as:"
msgstr "Então, quando devemos usar um session bean em vez de um simples managed bean? Sempre que precisar dos serviços corporativos avançados oferecidos por EJB, tais como:"

#. Tag: para
#, no-c-format
msgid "method-level transaction management and security,"
msgstr "gerenciamento de transação e segurança em nível de método,"

#. Tag: para
#, no-c-format
msgid "concurrency management,"
msgstr "gerenciamento de concorrência,"

#. Tag: para
#, no-c-format
msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
msgstr "passivação em nível de instância para stateful session bean e pooling de instâncias para stateless session beans,"

#. Tag: para
#, no-c-format
msgid "remote or web service invocation, or"
msgstr "invocação remota ou de serviço web, ou"

#. Tag: para
#, no-c-format
msgid "timers and asynchronous methods,"
msgstr "temporizadores e métodos assíncronos."

#. Tag: para
#, fuzzy, no-c-format
msgid "When we don&#39;t need any of these things, an ordinary managed bean will serve just fine."
msgstr "Quando não precisamos de nenhuma dessas coisas, um managed bean comum servirá muito bem."

#. Tag: para
#, no-c-format
msgid "Many beans (including any <literal>@SessionScoped</literal> or <literal>@ApplicationScoped</literal> beans) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped beans should be EJBs."
msgstr "Muitos beans (incluindo qualquer bean <literal>@SessionScoped</literal> ou <literal>@ApplicationScoped</literal>) estão disponíveis para acesso concorrente. Portanto, o gerenciamento de concorrência oferecido por EJB 3.1 é especialmente útil. A maioria dos beans com escopo de sessão e aplicação devem ser EJBs."

#. Tag: para
#, no-c-format
msgid "Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB stateless/stateful/singleton model, with its support for passivation and instance pooling."
msgstr "Os beans que mantêm referências a recursos muito pesados, ou tiram muito proveito do estado interno do avançado ciclo de vida gerenciado pelo contêiner, definido pelo modelo stateless/stateful/singleton de EJB, com seu suporte a passivação e pooling de instâncias."

#. Tag: para
#, fuzzy, no-c-format
msgid "Finally, it&#39;s usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
msgstr "Finalmente, normalmente é óbvio quando gerenciamento de transação a nível de método, segurança a nível de método, temporizadores, métodos remotos ou métodos assíncronos são utilizados."

#. Tag: para
#, fuzzy, no-c-format
msgid "The point we&#39;re trying to make is: use a session bean when you need the services it provides, not just because you want to use dependency injection, lifecycle management, or interceptors. Java EE 6 provides a graduated programming model. It&#39;s usually easy to start with an ordinary managed bean, and later turn it into an EJB just by adding one of the following annotations: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
msgstr "O ponto que estamos tentando determinar é: usar um session bean quando você precisar dos serviços que ele oferece, não apenas porque você quer usar injeção de dependência, gerenciamento de ciclo de vida, ou interceptadores. Java EE 6 fornece um modelo de programação graduado. É normalmente fácil iniciar com um managed bean habitual e, posteriormente, transformá-lo em um EJB apenas adicionando uma das seguintes anotações: <literal>@Stateless</literal>, <literal>@Stateful</literal> ou <literal>@Singleton</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "On the other hand, don&#39;t be scared to use session beans just because you&#39;ve heard your friends say they&#39;re &#34;heavyweight&#34;. It&#39;s nothing more than superstition to think that something is &#34;heavier&#34; just because it&#39;s hosted natively within the Java EE container, instead of by a proprietary bean container or dependency injection framework that runs as an additional layer of obfuscation. And as a general principle, you should be skeptical of folks who use vaguely defined terminology like &#34;heavyweight&#34;."
msgstr "Por outro lado, não tenha medo de usar session beans apenas porque você ouviu seus amigos dizer que eles são \"pesados\". Não é nada mais do que superstição pensar que alguma coisa é \"mais pesada\" apenas porque é hospedada nativamente dentro do contêiner Java EE, em vez de um contêiner proprietário de beans ou um framework de injeção de dependência que executa como uma camada adicional de ofuscação. E como um princípio geral, você deve desconfiar de pessoas que usam uma terminologia vagamente definida, como \"pesado\"."

#. Tag: title
#, no-c-format
msgid "Producer methods"
msgstr "Métodos produtores"

#. Tag: para
#, no-c-format
msgid "Not everything that needs to be injected can be boiled down to a bean class instantiated by the container using <literal>new</literal>. There are plenty of cases where we need additional control. What if we need to decide at runtime which implementation of a type to instantiate and inject? What if we need to inject an object that is obtained by querying a service or transactional resource, for example by executing a JPA query?"
msgstr "Nem tudo que precisa ser injetado pode ser resumido a uma classe de bean sendo instanciada pelo contêiner usando <literal>new</literal>. Existe uma abundância de casos onde precisamos de controle adicional. E se precisamos decidir em tempo de execução qual implementação de um dado tipo deve ser instanciado e injetado? E se precisamos injetar um objeto que é obtido ao consultar um serviço ou um recurso transacional, por exemplo, executando uma consulta JPA?"

#. Tag: para
#, no-c-format
msgid "A <emphasis>producer method</emphasis> is a method that acts as a source of bean instances. The method declaration itself describes the bean and the container invokes the method to obtain an instance of the bean when no instance exists in the specified context. A producer method lets the application take full control of the bean instantiation process."
msgstr "Um <emphasis>método produtor</emphasis> é um método que age como uma fonte de instâncias de bean. A própria declaração do método descreve o bean e o contêiner invoca o método para obter uma instância do bean quando nenhuma instância existe no contexto especificado. Um método produtor permite que a aplicação tome o controle total do processo de instanciação do bean."

#. Tag: para
#, no-c-format
msgid "A producer method is declared by annotating a method of a bean class with the <literal>@Produces</literal> annotation."
msgstr "Um método produtor é declarado anotando um método de uma classe de bean com a anotação <literal>@Produces</literal>."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@ApplicationScoped\n"
"public class RandomNumberGenerator {\n"
"   \n"
"   private Random random = new Random(System.currentTimeMillis());\n"
"       \n"
"   @Produces @Named @Random int getRandomNumber() {\n"
"      return random.nextInt(100);\n"
"   }\n"
"   \n"
"}"
msgstr ""
"<![CDATA[@ApplicationScoped\n"
"public class RandomNumberGenerator {\n"
"   \n"
"   private Random random = new Random(System.currentTimeMillis());\n"
"       \n"
"   @Produces @Named @Random int getRandomNumber() {\n"
"      return random.nextInt(100);\n"
"   }\n"
"   \n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We can&#39;t write a bean class that is itself a random number. But we can certainly write a method that returns a random number. By making the method a producer method, we allow the return value of the method—in this case an <literal>Integer</literal>—to be injected. We can even specify a qualifier—in this case <literal>@Random</literal>, a scope—which in this case defaults to <literal>@Dependent</literal>, and an EL name—which in this case defaults to <literal>randomNumber</literal> according to the JavaBeans property name convention. Now we can get a random number anywhere:"
msgstr "Não podemos escrever uma classe de bean que é ela própria um número aleatório. Mas podemos certamente escrever um método que retorna um número aleatório. Ao tornar o método um método produtor, permitimos que o valor de retorno do método—neste caso um <literal>Integer</literal>—seja injetado. Podemos até mesmo especificar um qualificador—neste caso <literal>@Random</literal>, um escopo—que neste caso é por padrão <literal>@Dependent</literal>, e um nome EL—que neste caso é por padrão <literal>randomNumber</literal> de acordo com a convenção JavaBeans para nome de propriedades. Agora podemos obter um número aleatório em qualquer lugar:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Random int randomNumber;"
msgstr "<![CDATA[@Inject @Random int randomNumber;]]>"

#. Tag: para
#, no-c-format
msgid "Even in a Unified EL expression:"
msgstr "Até mesmo em uma expressão Unified EL:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "&#60;p&#62;Your raffle number is #{randomNumber}.&#60;/p&#62;"
msgstr "<![CDATA[<p>Your raffle number is #{randomNumber}.</p>]]>"

#. Tag: para
#, no-c-format
msgid "A producer method must be a non-abstract method of a managed bean class or session bean class. A producer method may be either static or non-static. If the bean is a session bean, the producer method must be either a business method of the EJB or a static method of the bean class."
msgstr "Um método produtor deve ser um método não-abstrato de uma classe de managed bean ou de uma classe de session bean. Um método produtor pode ser estático ou não-estático. Se o bean é um session bean, o método produtor deve ser um método de negócio do EJB ou um método estático da classe do bean."

#. Tag: para
#, no-c-format
msgid "The bean types of a producer method depend upon the method return type:"
msgstr "Os tipos de bean de um método produtor depende do tipo de retorno do método:"

#. Tag: para
#, no-c-format
msgid "If the return type is an interface, the unrestricted set of bean types contains the return type, all interfaces it extends directly or indirectly and <literal>java.lang.Object</literal>."
msgstr "Se o tipo de retorno é uma interface, o conjunto ilimitado de tipos de bean contém o tipo de retorno, todas as interfaces estendidas direta ou indiretamente e <literal>java.lang.Object</literal>."

#. Tag: para
#, no-c-format
msgid "If a return type is primitive or is a Java array type, the unrestricted set of bean types contains exactly two types: the method return type and <literal>java.lang.Object</literal>."
msgstr "Se um tipo tipo de retorno é primitivo ou é um tipo de array Java, o conjunto ilimitado de tipos de bean contém exatamente dois tipos: o tipo de retorno do método e <literal>java.lang.Object</literal>."

#. Tag: para
#, no-c-format
msgid "If the return type is a class, the unrestricted set of bean types contains the return type, every superclass and all interfaces it implements directly or indirectly."
msgstr "Se o tipo de retorno é uma classe, o conjunto ilimitado de tipos de bean contém o tipo de retorno, todas superclasses e todas as interfaces implementadas direta ou indiretamente."

#. Tag: para
#, no-c-format
msgid "Producer methods and fields may have a primitive bean type. For the purpose of resolving dependencies, primitive types are considered to be identical to their corresponding wrapper types in <literal>java.lang</literal>."
msgstr "Os métodos e campos produtores podem ter um tipo primitivo como bean. Para o propósito de resolver dependências, tipos primitivos são considerados idênticos aos seus correspondentes tipos adaptadores em <literal>java.lang</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "If the producer method has method parameters, the container will look for a bean that satisfies the type and qualifiers of each parameter and pass it to the method automatically—another form of dependency injection."
msgstr "Se o método produtor possuir parâmetros, o contêiner buscará por um bean que satisfaça o tipo e os qualificadores de cada parâmetro e os passará para o método automaticamente—uma outra forma de injeção de dependência."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces Set&#60;Roles&#62; getRoles(User user) {\n"
"   return user.getRoles();\n"
"}"
msgstr ""
"<![CDATA[@Produces Set<Roles> getRoles(User user) {\n"
"   return user.getRoles();\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We&#39;ll talk much more about producer methods in <xref linkend=\"producermethods\" />."
msgstr "Falaremos mais sobre métodos produtores no <xref linkend=\"producermethods\" />."

#. Tag: title
#, no-c-format
msgid "Producer fields"
msgstr "Campos produtores"

#. Tag: para
#, fuzzy, no-c-format
msgid "A <emphasis>producer field</emphasis> is a simpler alternative to a producer method. A producer field is declared by annotating a field of a bean class with the <literal>@Produces</literal> annotation—the same annotation used for producer methods."
msgstr "Um <emphasis>campo produtor</emphasis> é uma alternativa mais simples para um método produtor. Um campo produtor é declarado ao anotar um campo de uma classe de bean com a anotação <literal>@Produces</literal>—a mesma anotação usada pelos métodos produtores."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Shop {\n"
"   @Produces PaymentProcessor paymentProcessor = ....;\n"
"   @Produces @Catalog List&#60;Product&#62; products = ....;\n"
"}"
msgstr ""
"<![CDATA[public class Shop {\n"
"   @Produces PaymentProcessor paymentProcessor = ....;\n"
"   @Produces @Catalog List<Product> products = ....;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "The rules for determining the bean types of a producer field parallel the rules for producer methods."
msgstr "As regras para determinação dos tipos de bean de um campo produtor assemelham-se às regras para métodos produtores."

#. Tag: para
#, fuzzy, no-c-format
msgid "A producer field is really just a shortcut that lets us avoid writing a useless getter method. However, in addition to convenience, producer fields serve a specific purpose as an adaptor for Java EE component environment injection, but to learn more about that, you&#39;ll have to wait until <xref linkend=\"resources\" />. Because we can&#39;t wait to get to work on some examples."
msgstr "Um campo produtor é realmente apenas um atalho que nos permite evitar escrever um método getter sem utilidade. No entanto, além da conveniência, campos produtores servem um propósito específico como um adaptador para injeção no ambiente de componentes Java EE, mas para aprender mais sobre isto, você terá que aguardar até o <xref linkend=\"resources\" />. Porque não podemos esperar para começar a trabalhar em alguns exemplos."
