# Language it-IT translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-12-14T13:35:17\n"
"PO-Revision-Date: 2008-12-25 12:11+0100\n"
"Last-Translator: Nicola Benaglia <nico.benaz@gmail.com>\n"
"Language-Team: none\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Introduction"
msgstr ""

# Rendere la frase "wondering what kinds of hoops the Web Beans specification will make you jump through!" più italiana.
#. Tag: para
#, fuzzy, no-c-format
msgid "So you&#39;re keen to get started writing your first bean? Or perhaps you&#39;re skeptical, wondering what kinds of hoops the CDI specification will make you jump through! The good news is that you&#39;ve probably already written and used hundreds, perhaps thousands of beans. CDI just makes it easier to actually use them to build an application!"
msgstr "Non vedi l'ora di iniziare a scrivere il primo Web Beans? O forse sei un pò scettico e ti domandi quali virtuosismi ti farà fare la specifica Web Beans! La buona notizia è che probabilmente hai già scritto e usato centinaia, forse migliaia di Web Beans. Potresti addirittura non ricordare il primo Web Bean scritto."

#. Tag: title
#, fuzzy, no-c-format
msgid "What is a bean?"
msgstr "Cosa è un Web Bean?"

#. Tag: para
#, no-c-format
msgid "A bean is exactly what you think it is. Only now, it has a true identity in the container environment."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Prior to Java EE 6, there was no clear definition of the term &#34;bean&#34; in the Java EE platform. Of course, we&#39;ve been calling Java classes used in web and enterprise applications &#34;beans&#34; for years. There were even a couple of different kinds of things called &#34;beans&#34; in EE specifications, including EJB beans and JSF managed beans. Meanwhile, other third-party frameworks such as Spring and Seam introduced their own ideas of what it meant to be a &#34;bean&#34;. What we&#39;ve been missing is a common definition."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java EE 6 finally lays down that common definition in the Managed Beans specification. Managed Beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks and interceptors. Companion specifications, such as EJB and CDI, build on this basic model. But, <emphasis>at last</emphasis>, there&#39;s a uniform concept of a bean and a lightweight component model that&#39;s aligned across the Java EE platform."
msgstr ""

#. Tag: para
#, no-c-format
msgid "With very few exceptions, almost every concrete Java class that has a constructor with no parameters (or a constructor designated with the annotation <literal>@Inject</literal>) is a bean. This includes every JavaBean and every EJB session bean. If you&#39;ve already got some JavaBeans or session beans lying around, they&#39;re already beans—you won&#39;t need any additional special metadata. There&#39;s just little one thing you need to do before you can start injecting them into stuff: you need to put them in an archive (a jar, or a Java EE module such as a war or EJB jar) that contains a special marker file: <literal>META-INF/beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The JavaBeans and EJBs you&#39;ve been writing every day, up until now, have not been able to take advantage of the new services defined by the CDI specification. But you&#39;ll be able to use every one of them with CDI—allowing the container to create and destroy instances of your beans and associate them with a designated context, injecting them into other beans, using them in EL expressions, specializing them with qualifier annotations, even adding interceptors and decorators to them—without modifying your existing code. At most, you&#39;ll need to add some annotations."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now let&#39;s see how to create your first bean that actually uses CDI."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Getting our feet wet"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Suppose that we have two existing Java classes that we&#39;ve been using for years in various applications. The first class parses a string into a list of sentences:"
msgstr "Si supponga di avere due classi Java esistenti, usate da anni in varie applicazioni. La prima classe esegue il parsing di una stringa in una lista di frasi:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class SentenceParser {\n"
"   public List&#60;String&#62; parse(String text) { ... }\n"
"}"
msgstr ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "The second existing class is a stateless session bean front-end for an external system that is able to translate sentences from one language to another:"
msgstr "La seconda classe è un session bean stateless front-end per un sistema esterno capace di tradurre le frasi da una lingua ad un altra:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"   public String translate(String sentence) { ... }\n"
"}"
msgstr ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>Translator</literal> is the EJB local interface:"
msgstr "Dove <literal>Translator</literal> è l'interfaccia locale:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Local\n"
"public interface Translator {\n"
"   public String translate(String sentence);\n"
"}"
msgstr ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, we don&#39;t have a class that translates whole text documents. So let&#39;s write a bean for this job:"
msgstr "Sfortunatamente non ci sono classi preesistenti che traducano l'intero testo dei documenti. Quindi occorre scrivere un Web Bean che faccia questo lavoro:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class TextTranslator {\n"
"   private SentenceParser sentenceParser;\n"
"   private Translator sentenceTranslator;\n"
"    \n"
"   @Inject\n"
"   TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"      this.sentenceParser = sentenceParser;\n"
"      this.sentenceTranslator = sentenceTranslator;\n"
"   }\n"
"    \n"
"   public String translate(String text) {\n"
"      StringBuilder sb = new StringBuilder();\n"
"      for (String sentence: sentenceParser.parse(text)) {\n"
"          sb.append(sentenceTranslator.translate(sentence));\n"
"      }\n"
"      return sb.toString();\n"
"   }\n"
"}"
msgstr ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "But wait! <literal>TextTranslator</literal> does not have a constructor with no parameters! Is it still a bean? If you remember, a class that does not have a constructor with no parameters can still be a bean if it has a constructor annotated <literal>@Inject</literal>."
msgstr "Ma <literal>TextTranslator</literal> non ha un costruttore con nessun parametro! E' ancora un Web Bean? Una classe che non ha un costruttore senza parametri può essere un Web Bean se il suo costruttore è annotato con <literal>@Initializer</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "As you&#39;ve guessed, the <literal>@Inject</literal> annotation has something to do with dependency injection! <literal>@Inject</literal> may be applied to a constructor or method of a bean, and tells the container to call that constructor or method when instantiating the bean. The container will inject other beans into the parameters of the constructor or method."
msgstr "Come hai indovinato, l'annotazione <literal>@Initializer</literal> ha qualcosa che fare con la dependency injection! <literal>@Initializer</literal> può essere applicato ad un costruttore od un metodo di un Web Bean, e dice al manager Web Bean di chiamare quel costruttore o metodo quando si istanzia il Web Bean. Il manager Web Bean inietterà altri Web Bean nei parametri del costruttore o del metodo."

#. Tag: para
#, no-c-format
msgid "We may obtain an instance of <literal>TextTranslator</literal> by injecting it into a constructor, method or field of a bean, or a field or method of a Java EE component class such as a servlet. The container chooses the object to be injected based on the type of the injection point, not the name of the field, method or parameter."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Let&#39;s create a UI controller bean that uses field injection to obtain an instance of the <literal>TextTranslator</literal>, translating the text entered by a user:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Named @RequestScoped\n"
"public class TranslateController {\n"
"   @Inject TextTranslator textTranslator;\n"
"\n"
"   private String inputText;\n"
"   private String translation;\n"
"\n"
"   // JSF action method, perhaps\n"
"   public void translate() {\n"
"      translation = textTranslator.translate(inputText); \n"
"   }\n"
"\n"
"   public String getInputText() {\n"
"      return inputText;\n"
"   }\n"
"\n"
"   public void setInputText(String text) {\n"
"      this.inputText = text;\n"
"   }\n"
"\n"
"   public String getTranslation() {\n"
"      return translation;\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Field injection of <literal>TextTranslator</literal> instance"
msgstr "Dove <literal>Translator</literal> è l'interfaccia locale:"

#. Tag: para
#, no-c-format
msgid "Notice the controller bean is request-scoped and named. Since this combination is so common in web applications, there&#39;s a built-in annotation for it in CDI that we could have used as a shorthand. When the (stereotype) annotation <literal>@Model</literal> is declared on a class, it creates a request-scoped and named bean."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Alternatively, we may obtain an instance of <literal>TextTranslator</literal> programmatically from an injected instance of <literal>Instance</literal>, parameterized with the bean type:"
msgstr "Si può ottenere un'istanza di <literal>TextTranslator</literal> iniettandolo in un Web Bean, Servlet o EJB:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject Instance&#60;TextTranslator&#62; textTranslatorInstance;\n"
"...\n"
"public void translate() {\n"
"   textTranslatorInstance.get().translate(inputText);\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Notice that it isn&#39;t necessary to create a getter or setter method to inject one bean into another. CDI can access an injected field directly (even if it&#39;s private!), which sometimes helps eliminate some wasteful code. The name of the field is arbitrary. It&#39;s the field&#39;s type that determines what is injected."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "At system initialization time, the container must validate that exactly one bean exists which satisfies each injection point. In our example, if no implementation of <literal>Translator</literal> is available—if the <literal>SentenceTranslator</literal> EJB was not deployed—the container would inform us of an <emphasis>unsatisfied dependency</emphasis>. If more than one implementation of <literal>Translator</literal> were available, the container would inform us of the <emphasis>ambiguous dependency</emphasis>."
msgstr "In fase di inizializzazione del sistema, il manager Web Bean deve convalidare che esattamente un solo Web Bean esista e soddisfi ciascun punto di iniezione. Nell'esempio, se nessuna implementazione di <literal>Translator</literal> fosse disponibile &#151; se l'EJB <literal>SentenceTranslator</literal> non venisse deployato &#151; il manager Web Bean lancerebbe una <literal>UnsatisfiedDependencyException</literal>. Se più di un'implementazione di <literal>Translator</literal> fosse disponibile, il manager Web Bean lancerebbe una <literal>AmbiguousDependencyException</literal>."

#. Tag: para
#, no-c-format
msgid "Before we get too deep in the details, let&#39;s pause and examine a bean&#39;s anatomy. What aspects of the bean are significant, and what gives it its identity? Instead of just giving examples of beans, we&#39;re going to define what <emphasis>makes</emphasis> something a bean."
msgstr ""

#~ msgid "Getting started with Web Beans"
#~ msgstr "Iniziare con Web Beans"

#~ msgid "Your first Web Bean"
#~ msgstr "Il primo Web Bean"

#~ msgid "With certain, very special exceptions, every Java class with a constructor that accepts no parameters is a Web Bean. That includes every JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. Sure, the JavaBeans and EJBs you've been writing every day have not been able to take advantage of the new services defined by the Web Beans specification, but you'll be able to use every one of them as Web Beans &#151; injecting them into other Web Beans, configuring them via the Web Beans XML configuration facility, even adding interceptors and decorators to them &#151; without touching your existing code."
#~ msgstr "Con alcune eccezioni molto particolari, ogni classe Java con un costruttore che non accetta parametri è un Web Bean. Questo include ogni JavaBean. Inoltre, ogni session bean di stile EJB3 è un Web Bean. Sicuramente i JavaBean e gli EJB3 che si sono sempre scritti non erano in grado di sfruttare i nuovi servizi definiti dalla specifica Web Beans, ma si sarà presto in grado di usare ciascuno di essi come Web Bean &#151; iniettandoli in altri Web Beans, configurandoli tramite strumenti di configurazione XML Web Bean, e perfino aggiungendo a loro interceptor e decoratori &#151; senza toccare il codice esistente."

#~ msgid "Alternatively, we may obtain an instance by directly calling a method of the Web Bean manager:"
#~ msgstr "In alternativa si può ottenere un'istanza chiamando direttamente un metodo del manager Web Bean:"

#~ msgid "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"
#~ msgstr "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"

#~ msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
#~ msgstr "Ma cosa è <emphasis>esattamente</emphasis> un Web Bean?"

#~ msgid "A Web Bean is an application class that contains business logic. A Web Bean may be called directly from Java code, or it may be invoked via Unified EL. A Web Bean may access transactional resources. Dependencies between Web Beans are managed automatically by the Web Bean manager. Most Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean manager."
#~ msgstr "Un Web Bean è una classe di un'applicazione che contiene della logica di business. Può essere chiamato direttamente da codice Java, o può essere invocato via Unified EL. Un Web Bean può accedere a risorse transazionali. Le dipendenze tra Web Beans sono gestite automaticamente dal manager Web Bean. La maggior parte dei Web Beans sono <emphasis>stateful</emphasis> e <emphasis>contestuali</emphasis>. Il ciclo di vita di un Web Bean è sempre gestito da un manager Web Bean."

#~ msgid "Let's back up a second. What does it really mean to be \"contextual\"? Since Web Beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a Web Bean see the Web Bean in different states. The client-visible state depends upon which instance of the Web Bean the client has a reference to."
#~ msgstr "Torniamo indietro un attimo. Cosa significa veramente essere \"contestuale\"? Poiché Web Beans può essere stateful, è importante <emphasis>quale</emphasis> istanza di bean si ha. Diversamente da un modello a componenti stateless (per esempio, i session bean stateless) o un modello a componenti singleton (come i servlet o i bean singleton) i client di un Web Bean vedono il Web Bean in stati differenti. Lo stato del client visibile dipende dall'istanza del Web Bean alla quale il client ha il riferimento."

#~ msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
#~ msgstr "Comunque, in modo simile ad un modello stateless o singleton, ma <emphasis>non come</emphasis> i session bean stateful, il client non ha il controllo sul ciclo di vita dell'istanza, creandola e distruggendola esplicitamente. Invece, lo <emphasis>scope</emphasis> del Web Bean determina:"

#~ msgid "the lifecycle of each instance of the Web Bean and"
#~ msgstr "il ciclo di vita di ogni istanza del Web Bean e"

#~ msgid "which clients share a reference to a particular instance of the Web Bean."
#~ msgstr "quali client condividono una referenza con una particolare istanza del Web Bean."

#~ msgid "For a given thread in a Web Beans application, there may be an <emphasis>active context</emphasis> associated with the scope of the Web Bean. This context may be unique to the thread (for example, if the Web Bean is request scoped), or it may be shared with certain other threads (for example, if the Web Bean is session scoped) or even all other threads (if it is application scoped)."
#~ msgstr "Per un dato thread in un'applicazione Web Beans, ci può essere un <emphasis>contesto attivo</emphasis> associato allo scope del Web Bean. Questo contesto può essere univoco nel thread (per esempio, se il Web Bean è con scope di richiesta), o può essere condiviso con alcuni altri thread (per esempio, se il Web Bean è con scope di sessione) od anche tutti gli altri thread (se è scope di applicazione). "

#~ msgid "Clients (for example, other Web Beans) executing in the same context will see the same instance of the Web Bean. But clients in a different context will see a different instance."
#~ msgstr "I client (per esempio, altri Web Beans) che sono in esecuzione nello stesso contesto vedranno la stessa istanza del Web Bean. Ma i client in un contesto diverso vedranno un istanza diversa."

#~ msgid "One great advantage of the contextual model is that it allows stateful Web Beans to be treated like services! The client need not concern itself with managing the lifecycle of the Web Bean it is using, <emphasis>nor does it even need to know what that lifecyle is.</emphasis> Web Beans interact by passing messages, and the Web Bean implementations define the lifecycle of their own state. The Web Beans are loosely coupled because:"
#~ msgstr "Un grande vantaggio del modello contestuale è che consente ai Web Beans stateful di essere trattati come servizi! Il client non deve preoccuparsi di gestire il ciclo di vita del Web Bean che sta utilizzando, <emphasis>e neppure deve sapere quale sia il ciclo di vita.</emphasis> Web Beans interagisce passando i messaggi, e le implementazioni Web Bean definiscono il ciclo di vita del proprio stato. I Web Beans sono debolmente disaccoppiati (loosely coupled) poiché:"

#~ msgid "they interact via well-defined public APIs"
#~ msgstr "interagiscono tramite delle API pubblica ben-definita"

#~ msgid "their lifecycles are completely decoupled"
#~ msgstr "il loro ciclo di vita è completamente disaccoppiato"

#~ msgid "We can replace one Web Bean with a different Web Bean that implements the same API and has a different lifecycle (a different scope) without affecting the other Web Bean implementation. In fact, Web Beans defines a sophisticated facility for overriding Web Bean implementations at deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "Si può sostituire un Web Bean con un diverso Web Bean che implementa la stessa API ed ha un diverso ciclo di vita (un diverso scope) senza alterare l'implementazione dell'altro Web Bean. Infatti Web Beans definisce un meccanismo sofisticato per fare l'override delle implementazioni Web Bean al momento del deploy, come visto in <xref linkend=\"deploymenttypes\"/>."

#~ msgid "Note that not all clients of a Web Bean are Web Beans. Other objects such as Servlets or Message-Driven Beans &#151; which are by nature not injectable, contextual objects &#151; may also obtain references to Web Beans by injection."
#~ msgstr "Si noti che non tutti i client dei un Web Bean sono Web Bean. Altri oggetti come Servlet o Message-Driven Beans &#151; che sono per natura non iniettabili, oggetti contestuali &#151; possono pure ottenere riferimenti a Web Bean tramite iniezione."

# Tolto "Enough hand-waving."
#~ msgid "Enough hand-waving. More formally, according to the spec:"
#~ msgstr "Più formalmente, secondo la specifica:"

#~ msgid "A Web Bean comprises:"
#~ msgstr "Un Web Bean comprende:"

#~ msgid "A (nonempty) set of API types"
#~ msgstr "Un set (non vuoto) di tipi di API"

#~ msgid "A (nonempty) set of binding annotation types"
#~ msgstr "Un set (non vuoto) di tipi di annotazione di binding"

#~ msgid "A scope"
#~ msgstr "Uno scope"

#~ msgid "A deployment type"
#~ msgstr "Un tipo di deploy"

#~ msgid "Optionally, a Web Bean name"
#~ msgstr "Opzionalmente un nome Web Bean"

#~ msgid "A set of interceptor binding types"
#~ msgstr "Un set di tipi di interceptor binding"

#~ msgid "A Web Bean implementation"
#~ msgstr "Un implementazione Web Bean"

#~ msgid "Let's see what some of these terms mean, to the Web Bean developer."
#~ msgstr "Vediamo cosa significano alcuni di questi termini per lo sviluppatore Web Bean."

#~ msgid "API types, binding types and dependency injection"
#~ msgstr "Tipi di API, tipi di binding e dependency injection"

#~ msgid "Web Beans usually acquire references to other Web Beans via dependency injection. Any injected attribute specifies a \"contract\" that must be satisfied by the Web Bean to be injected. The contract is:"
#~ msgstr "I Web Bean solitamente acquisiscono riferimenti ad altri Web Bean tramite la dependency injection. Ogni attributo iniettato specifica un \"contratto\" che deve essere soddisfatto dal Web Bean per essere iniettato. Il contratto è:"

#~ msgid "an API type, together with"
#~ msgstr "un tipo di API, assieme a"

#~ msgid "a set of binding types."
#~ msgstr "un set di tipi di binding"

# client-visible semantic  =?
#~ msgid "An API is a user-defined class or interface. (If the Web Bean is an EJB session bean, the API type is the <literal>@Local</literal> interface or bean-class local view). A binding type represents some client-visible semantic that is satisfied by some implementations of the API and not by others."
#~ msgstr "Un API è una classe o interfaccia definita dall'utente. (Se il Web Bean è un session bean EJB, il tipo di API è l'interfaccia <literal>@Local</literal> o la vista locale della classe-bean). Un tipo di binding rappresenta un semantica del client che è soddisfatta da certe implementazioni dell'API e non da altre."

#~ msgid "Binding types are represented by user-defined annotations that are themselves annotated <literal>@BindingType</literal>. For example, the following injection point has API type <literal>PaymentProcessor</literal> and binding type <literal>@CreditCard</literal>:"
#~ msgstr "I tipi di binding sono rappresentati da annotazioni definite dall'utente che sono loro stesse annotate con <literal>@BindingType</literal>. Per esempio, il seguente punto di iniezione ha un tipo di API <literal>PaymentProcessor</literal> ed un tipo di binding <literal>@CreditCard</literal>:"

#~ msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
#~ msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#~ msgid "If no binding type is explicitly specified at an injection point, the default binding type <literal>@Current</literal> is assumed."
#~ msgstr "Se nessun tipo di binding viene specificato in modo esplicito ad un punto di iniezione, il tipo di binding di default si assume essere <literal>@Current</literal>."

#~ msgid "For each injection point, the Web Bean manager searches for a Web Bean which satisfies the contract (implements the API, and has all the binding types), and injects that Web Bean."
#~ msgstr "Per ogni punto di iniezione, il manager Web Bean cerca un Web Bean che soddisfi il contratto (che implementi la API, e che abbia tutti i tipi di binding), ed inietta tale Web Bean."

#~ msgid "The following Web Bean has the binding type <literal>@CreditCard</literal> and implements the API type <literal>PaymentProcessor</literal>. It could therefore be injected to the example injection point:"
#~ msgstr "Il seguente Web Bean ha il tipo binding <literal>@CreditCard</literal> e implementa il tipo API <literal>PaymentProcessor</literal>. Può quindi essere iniettato nel punto di iniezione d'esempio:"

#~ msgid ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@CreditCard\n"
#~ "public class CreditCardPaymentProcessor \n"
#~ "    implements PaymentProcessor { ... }]]>"

#~ msgid "If a Web Bean does not explicitly specify a set of binding types, it has exactly one binding type: the default binding type <literal>@Current</literal>."
#~ msgstr "Se un Web Bean non specifica esplicitamente un set di tipi di binding, ha esattamente un solo tipo di binding: il tipo di binding di default <literal>@Current</literal>."

#~ msgid "Web Beans defines a sophisticated but intuitive <emphasis>resolution algorithm</emphasis> that helps the container decide what to do if there is more than one Web Bean that satisfies a particular contract. We'll get into the details in <xref linkend=\"injection\"/>."
#~ msgstr "Web Beans definisce un <emphasis>algoritmo di risoluzione</emphasis> sofisticato ma intuitivo che aiuta il container a decidere cosa fare se più di un Web Bean soddisfa un particolare contratto. Vedremo i dettagli in <xref linkend=\"injection\"/>."

#~ msgid "Deployment types"
#~ msgstr "Tipi di deploy"

#~ msgid "<emphasis>Deployment types</emphasis> let us classify our Web Beans by deployment scenario. A deployment type is an annotation that represents a particular deployment scenario, for example <literal>@Mock</literal>, <literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We apply the annotation to Web Beans which should be deployed in that scenario. A deployment type allows a whole set of Web Beans to be conditionally deployed, with a just single line of configuration."
#~ msgstr "<emphasis>I tipi di deploy</emphasis> consentono di classificare i Web Bean secondo uno scenario di deploy. Un tipo di deploy è un'annotazione che rappresenta un particolare scenario di deploy, per esempio <literal>@Mock</literal>, <literal>@Staging</literal> oppure <literal>@AustralianTaxLaw</literal>. Si applica l'annotazione ai Web Bean che dovrebbero essere deployati in tale scenario. Un tipo di deploy consente ad un intero set di Web Bean di essere deployati in modo condizionato, con una sola linea di configurazione."

#~ msgid "Many Web Beans just use the default deployment type <literal>@Production</literal>, in which case no deployment type need be explicitly specified. All three Web Bean in our example have the deployment type <literal>@Production</literal>."
#~ msgstr "Molti Web Bean usano soltanto il tipo di deploy di default <literal>@Production</literal>, ed in questo caso non occorre specificare esplicitamente nessun tipo di deploy. Tutti e tre i Web Bean d'esempio hanno ul tipo di deploy <literal>@Production</literal>. "

#~ msgid "In a testing environment, we might want to replace the <literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
#~ msgstr "In un ambiente di test è possibile sostituire il Web Bean <literal>SentenceTranslator</literal> con un \"oggetto mock\":"

#~ msgid ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock\n"
#~ "public class MockSentenceTranslator implements Translator {\n"
#~ "    public String translate(String sentence) {\n"
#~ "        return \"Lorem ipsum dolor sit amet\";\n"
#~ "    }\n"
#~ "}]]>"

#~ msgid "We would enable the deployment type <literal>@Mock</literal> in our testing environment, to indicate that <literal>MockSentenceTranslator</literal> and any other Web Bean annotated <literal>@Mock</literal> should be used."
#~ msgstr "In ambiente di test si dovrebbe abilitare il tipo di deploy <literal>@Mock</literal> per indicare che l'uso di <literal>MockSentenceTranslator</literal> ed ogni altro Web Bean annotato con <literal>@Mock</literal>."

#~ msgid "We'll talk more about this unique and powerful feature in <xref linkend=\"deploymenttypes\"/>."
#~ msgstr "Si discuterà questa potente funzionalità con maggior dettaglio in <xref linkend=\"deploymenttypes\"/>.\" "

#~ msgid "Scope"
#~ msgstr "Scope"

# arbitrary scope è corretto "scope arbitrari" ?
#~ msgid "The <emphasis>scope</emphasis> defines the lifecycle and visibility of instances of the Web Bean. The Web Beans context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built-in to the specification, and provided by the Web Bean manager. A scope is represented by an annotation type."
#~ msgstr "Lo <emphasis>scope</emphasis> definisce il ciclo di vita e la visibilità delle istanze di Web Bean. Il modello di contesto Web Bean è estensibile e facilita gli scope arbitrari. Comunque alcuni importanti scope sono predefiniti all'internodella specifica e vengono forniti dal manager Web Bean. Uno scope è rapresentato da un tipo di annotazione."

#~ msgid "For example, any web application may have <emphasis>session scoped</emphasis> Web Beans:"
#~ msgstr "Per esempio un'applicazione web può avere Web Bean con <emphasis>scope di sessione</emphasis>"

#~ msgid ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "An instance of a session scoped Web Bean is bound to a user session and is shared by all requests that execute in the context of that session."
#~ msgstr "Un'istanza di un Web Bean con scope sessione è legato ad una sessione utente ed è condivisa da tutte le richieste che si eseguono nel contesto di tale sessione."

#~ msgid "By default, Web Beans belong to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope are pure dependent objects of the object into which they are injected, and their lifecycle is bound to the lifecycle of that object."
#~ msgstr "Di default i Web Bean appartengono ad uno speciale scope chiamato <emphasis>pseudo-scope dipendente</emphasis>. Web Bean con questo scope sono oggetti puri dipendenti dall'oggetto nel quale vengono iniettati ed il loro ciclo di vita è legato al ciclo di vita di tale oggetto."

#~ msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
#~ msgstr "Approfondiremo gli scope in <xref linkend=\"scopescontexts\"/>."

#~ msgid "Web Bean names and Unified EL"
#~ msgstr "Nomi Web Bean e Unified EL"

#~ msgid "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used in Unified EL expressions. It's easy to specify the name of a Web Bean:"
#~ msgstr "Un Web Bean può avere un <emphasis>nome</emphasis> che gli consente di essere usato in un'espressione Unified EL. E' facile specificare il nome del Web Bean:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named(\"cart\")\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
#~ msgstr "Ora si può facilmente utilizzare il Web Bean in ogni pagina JSF o JSP:"

#~ msgid ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"
#~ msgstr ""
#~ "<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
#~ "    ....\n"
#~ "</h:dataTable>]]>"

#~ msgid "It's even easier to just let the name be defaulted by the Web Bean manager:"
#~ msgstr "Si può anche lasciare assegnare al manager Web Bean il nome di default:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Named\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "In this case, the name defaults to <literal>shoppingCart</literal> &#151; the unqualified class name, with the first character changed to lowercase."
#~ msgstr "In questo caso il nome di default è <literal>shoppingCart</literal> &#151; il nome della classe non qualificata, con il primo carattere messo in minuscolo."

#~ msgid "Interceptor binding types"
#~ msgstr "Tipi di interceptor binding"

#~ msgid "Web Beans supports the interceptor functionality defined by EJB 3, not only for EJB beans, but also for plain Java classes. In addition, Web Beans provides a new approach to binding interceptors to EJB beans and other Web Beans."
#~ msgstr "Web Beans supporta la funzionalità di interceptor definita da EJB 3, non solo per i bean EJB, ma anche per classi Java semplici (plain). In aggiunta, Web Beans fornisce un nuovo approccio al binding di interceptor nei confronti di bean EJB e di altri Web Beans."

#~ msgid "It remains possible to directly specify the interceptor class via use of the <literal>@Interceptors</literal> annotation:"
#~ msgstr "Rimane la possibilità di specificare direttamente la classe interceptor tramite l'uso dell'annotazione <literal>@Interceptors</literal>."

#~ msgid ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped \n"
#~ "@Interceptors(TransactionInterceptor.class)\n"
#~ "public class ShoppingCart { ... }]]>"

# indirect = ?
#~ msgid "However, it is more elegant, and better practice, to indirect the interceptor binding through an <emphasis>interceptor binding type</emphasis>:"
#~ msgstr "Comunque è più elegante ed è considerata una pratica migliore quella di giungere indirettamente ad un interceptor binding tramite un <emphasis>tipo di interceptor binding</emphasis>:"

#~ msgid ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"
#~ msgstr ""
#~ "<![CDATA[@SessionScoped @Transactional\n"
#~ "public class ShoppingCart { ... }]]>"

#~ msgid "We'll discuss Web Beans interceptors and decorators in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/>."
#~ msgstr "Si discuteranno gli interceptor e i decoratori di Web BEans in <xref linkend=\"interceptors\"/> e <xref linkend=\"decorators\"/>."

#~ msgid "What kinds of objects can be Web Beans?"
#~ msgstr "Quali tipi di oggetti possono essere Web Beans?"

#~ msgid "We've already seen that JavaBeans, EJBs and some other Java classes can be Web Beans. But exactly what kinds of objects are Web Beans?"
#~ msgstr "Si è già visto che JavaBeans, EJB ed altri tipi di classi Java possono essere Web Bean. Ma esattamente quali tipi di oggetti sono Web Beans?"

#~ msgid "Simple Web Beans"
#~ msgstr "Web Beans Semplici"

#~ msgid "The Web Beans specification says that a concrete Java class is a <emphasis>simple</emphasis> Web Bean if:"
#~ msgstr "La specifica Web Beans dice che una classe concreta Java è un Web Bean <emphasis>semplice</emphasis> se:"

#~ msgid "it is not an EE container-managed component, like an EJB, a Servlet or a JPA entity,"
#~ msgstr "Non è un componente gestito da un container EE, come EJB, un Servlet o un entity JPA,"

#~ msgid "it is not a non-static static inner class,"
#~ msgstr "non è una classe interna statica/non statica,"

#~ msgid "it is not a parameterized type, and"
#~ msgstr "non è un tipo parametrizzato, e"

#~ msgid "it has a constructor with no parameters, or a constructor annotated <literal>@Initializer</literal>."
#~ msgstr "ha un costruttore senza parametro, o un costruttore annotato con <literal>@Initializer</literal>."

#~ msgid "Thus, almost every JavaBean is a simple Web Bean."
#~ msgstr "Quindi quasi ogni JavaBean è un Web Bean semplice."

#~ msgid "Every interface implemented directly or indirectly by a simple Web Bean is an API type of the simple Web Bean. The class and its superclasses are also API types."
#~ msgstr "Ogni interfaccia implementata direttamente o indirettamente da un Web Bean semplice è un tipo di API di un Web Bean semplice. La classe e le sue superclassi sono anch'essere tipi di API."

#~ msgid "Enterprise Web Beans"
#~ msgstr "Web Bean Enterprise"

#~ msgid "The specification says that all EJB 3-style session and singleton beans are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are not Web Beans &#151; since they are not intended to be injected into other objects &#151; but they can take advantage of most of the functionality of Web Beans, including dependency injection and interceptors."
#~ msgstr "La specifica dice che tutti i bean di sessione stile EJB3 e quelli singleton sono Web Bean <emphasis>enterprise</emphasis>. I bean message driven non sono Web Bean &#151; poiché non sono intesi per essere iniettati in altri oggetti &#151; ma possono sfruttare la maggior parte della funzionalità dei Web Bean, inclusi dependency injection e interceptor."

# bean class local view = ?
#~ msgid "Every local interface of an enterprise Web Bean that does not have a wildcard type parameter or type variable, and every one of its superinterfaces, is an API type of the enterprise Web Bean. If the EJB bean has a bean class local view, the bean class, and every one of its superclasses, is also an API type."
#~ msgstr "Ogni interfaccia locale di un Web Bean enterprise che non ha un parametro tipo wildcard o variabile tipo, e ciascuna delle sue superinterfacce, è un tipo di API del Web Bean enterprise. Se il bean EJB ha una vista locale di classe bean, la classe bean e ogni sua superclasse è anch'essa un tipo di API."

#~ msgid "Stateful session beans should declare a remove method with no parameters or a remove method annotated <literal>@Destructor</literal>. The Web Bean manager calls this method to destroy the stateful session bean instance at the end of its lifecycle. This method is called the <emphasis>destructor</emphasis> method of the enterprise Web Bean."
#~ msgstr "I session bean stateful dovrebbero dichiarare un metodo remoto senza parametri od un metodo annotato con <literal>@Destructor</literal>. Il manager Web Bean chiama questo metodo per distruggere l'istanza del session bean statefull alla fine del suo ciclo di vita. Questo metodo è chiamato metodo <emphasis>distruttore</emphasis> del Web Bean enterprise."

#~ msgid ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Stateful @SessionScoped\n"
#~ "public class ShoppingCart {\n"
#~ "\n"
#~ "    ...\n"
#~ "    \n"
#~ "    @Remove\n"
#~ "    public void destroy() {}\n"
#~ "\n"
#~ "}]]>"

#~ msgid "So when should we use an enterprise Web Bean instead of a simple Web Bean? Well, whenever we need the advanced enterprise services offered by EJB, such as:"
#~ msgstr "Ma allora quando occorre usare un Web Bean enterprise invece di un Web Bean semplice? Quando occorrono servizi enterprise avanzati offerti da EJB, quali:"

#~ msgid "method-level transaction management and security,"
#~ msgstr "gestione delle transazioni a livello di metodo e sicurezza,"

#~ msgid "concurrency management,"
#~ msgstr "gestione della concorrenza,"

#~ msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
#~ msgstr "passivazione a livello di istanza per session bean stateful e pooling di istanze per session bean stateless,"

#~ msgid "remote and web service invocation, and"
#~ msgstr "invocazione remota e web service, e"

#~ msgid "timers and asynchronous methods,"
#~ msgstr "timer e metodi asincroni,"

#~ msgid "we should use an enterprise Web Bean. When we don't need any of these things, a simple Web Bean will serve just fine."
#~ msgstr "si dovrebbe usare un Web Bean enterprise. Quando non occorrono queste cose, va bene utilizzare un Web Bean semplice."

#~ msgid "Many Web Beans (including any session or application scoped Web Bean) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped Web Beans should be EJBs."
#~ msgstr "Molti Web Bean (inclusi Web Bean con scope di sessione o applicazione) sono disponibili per accessi concorrenti. Quindi la gestione della concorrenza fornita da EJB3.1 è molto utile. La maggior parte dei Web Bean con scope sessione e applicazione dovrebbero essere EJB."

# internal state benefit =?
#~ msgid "Web Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> model, with its support for passivation and instance pooling."
#~ msgstr "Web Bean che mantengono riferimenti alle risorse pesanti o mantengono molti benefici dello stato interno dal ciclo di vita avanzato, gestito dal container, definito dal modello EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal>\", con supporto alla passivazione e pooling delle istanze."

#~ msgid "Finally, it's usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
#~ msgstr "Infine è ovvio quando occorre usare la gestione delle transazioni a livello di metodo, la sicurezza a livello di metoto, i timer, i metodi remoti o i metodi asincroni."

#~ msgid "It's usually easy to start with simple Web Bean, and then turn it into an EJB, just by adding an annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
#~ msgstr "E' facile iniziare con un Web Bean semplice e poi volgere a EJB semplicemente aggiungendo l'annotazione: <literal>@Stateless</literal>, <literal>@Stateful</literal> o <literal>@Singleton</literal>."

#~ msgid "Producer methods"
#~ msgstr "Metodi produttori"

#~ msgid "A <emphasis>producer method</emphasis> is a method that is called by the Web Bean manager to obtain an instance of the Web Bean when no instance exists in the current context. A producer method lets the application take full control of the instantiation process, instead of leaving instantiation to the Web Bean manager. For example:"
#~ msgstr "Un <emphasis>metodo produttore</emphasis> è un metodo che viene chiamato dal manager Web Bean per ottenere un'istanza di un Web Bean quando non esiste alcuna istanza nel contesto corrente. Un metodo produttore lascia all'applicazione il pieno controllo del processo di istanziamento, invece di lasciare l'istanziamento al manager Web Bean. Per esempio:"

#~ msgid ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@ApplicationScoped\n"
#~ "public class Generator {\n"
#~ "\n"
#~ "    private Random random = new Random( System.currentTimeMillis() );\n"
#~ "    \n"
#~ "    @Produces @Random int next() {\n"
#~ "        return random.nextInt(100);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "The result of a producer method is injected just like any other Web Bean."
#~ msgstr "Il risultato del metodo produttore è iniettato come qualsiasi altro Web Bean."

#~ msgid "<![CDATA[@Random int randomNumber]]>"
#~ msgstr "<![CDATA[@Random int randomNumber]]>"

#~ msgid "The method return type and all interfaces it extends/implements directly or indirectly are API types of the producer method. If the return type is a class, all superclasses are also API types."
#~ msgstr "Il tipo di ritorno del metodo e tutte le interfacce che estende/implementa direttamente o indirettamente sono tipi di API del metodo produttore. Se il tipo di ritorno è una classe, tutte le superclassi sono anch'esse tipi di API."

#~ msgid "Some producer methods return objects that require explicit destruction:"
#~ msgstr "Alcuni metodi produttori restituiscono oggetti che richiedono una distruzione esplicita:"

#~ msgid ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
#~ "    return createConnection( user.getId(), user.getPassword() );\n"
#~ "}]]>"

#~ msgid "These producer methods may define matching <emphasis>disposal methods</emphasis>:"
#~ msgstr "Questi metodi produttori possono definire corrispondenti <emphasis>metodi distruttori</emphasis>:\""

#~ msgid ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[void close(@Disposes Connection connection) {\n"
#~ "    connection.close();\n"
#~ "}]]>"

#~ msgid "This disposal method is called automatically by the Web Bean manager at the end of the request."
#~ msgstr "Il metodo distruttore è chiamato direttamente dal manager Web Bean alla fine della richiesta."

#~ msgid "We'll talk much more about producer methods in <xref linkend=\"producermethods\"/>."
#~ msgstr "Si parlerà in maggior dettaglio dei metodi produttori in <xref linkend=\"producermethods\"/>."

#~ msgid "JMS endpoints"
#~ msgstr "Endpoint JMS"

#~ msgid "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the developer from the tedium of managing the lifecycles of all the various JMS objects required to send messages to queues and topics. We'll discuss JMS endpoints in <xref linkend=\"jms\"/>."
#~ msgstr "Infine una coda od un topic JMS possono essere Web Bean. Web Beans solleva lo sviluppatore dalla noia della gestione dei cicli di vita di tutti i vari oggetti JMS richiesto per inviare messaggi a code o topic. Si discuteranno gli endpoint JMS in <xref linkend=\"jms\"/>."
