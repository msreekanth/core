# translation of injection.po to Spanish
# Language es-ES translations for master.xml package.
#
# Automatically generated, 2008.
# Gladys Guerrero Lozano <gguerrer@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: injection\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-12-14T13:35:17\n"
"PO-Revision-Date: 2009-01-19 15:18+1000\n"
"Last-Translator: Gladys Guerrero Lozano <gguerrer@redhat.com>\n"
"Language-Team: Spanish <fedora-trans-es@redhat.com>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#, fuzzy, no-c-format
msgid "Dependency injection and programmatic lookup"
msgstr "Inyección de dependencia"

#. Tag: para
#, no-c-format
msgid "One of the most significant features of CDI—certainly the most recognized—is dependency injection; excuse me, <emphasis>typesafe</emphasis> dependency injection."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Injection points"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The <literal>@Inject</literal> annotation lets us define an injection point that is injected during bean instantiation. Injection can occur via three different mechanisms."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Bean constructor</emphasis> parameter injection:"
msgstr "Inyección de parámetro del método <emphasis>Inicializador</emphasis>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can only have one injectable constructor."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "<emphasis>Initializer method</emphasis> parameter injection:"
msgstr "Inyección de parámetro del método <emphasis>Inicializador</emphasis>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "A bean can have multiple initializer methods. If the bean is a session bean, the initializer method is not required to be a business method of the session bean."
msgstr ""

#. Tag: para
#, no-c-format
msgid "And direct field injection:"
msgstr "E inyección directa de campo:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}"
msgstr ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Getter and setter methods are not required for field injection to work (unlike with JSF managed beans)."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Dependency injection always occurs when the bean instance is first instantiated by the container. Simplifying just a little, things happen in this order:"
msgstr "La inyección de dependencia siempre se presenta cuando la instancia de Web Bean es instanciada primero:"

#. Tag: para
#, fuzzy, no-c-format
msgid "First, the container calls the bean constructor (the default constructor or the one annotated <literal>@Inject</literal>), to obtain an instance of the bean."
msgstr "Primero, el administrador de Web Bean llama al constructor de Web Bean, para obtener una instancia del Web Bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container initializes the values of all injected fields of the bean."
msgstr "Luego, el administrador de Web Bean inicializa los valores de los campos inyectados del Web Bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "Next, the container calls all initializer methods of bean (the call order is not portable, don&#39;t rely on it)."
msgstr "Más tarde, el administrador de Web Bean llama a todos los métodos inicializadores del Web Bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "Finally, the <literal>@PostConstruct</literal> method, if any, is called."
msgstr "Por último, se llama al método de Web Bean <literal>@PostConstruct</literal>, si existe."

#. Tag: para
#, no-c-format
msgid "(The only complication is that the container might call initializer methods declared by a superclass before initializing injected fields declared by a subclass.)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "One major advantage of constructor injection is that it allows the bean to be immutable."
msgstr ""

#. Tag: para
#, no-c-format
msgid "CDI also supports parameter injection for some other methods that are invoked by the container. For instance, parameter injection is supported for producer methods:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}"
msgstr ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "This is a case where the <literal>@Inject</literal> annotation <emphasis>is not</emphasis> required at the injection point. The same is true for observer methods (which we&#39;ll meet in <xref linkend=\"events\" />) and disposer methods."
msgstr ""

#. Tag: title
#, no-c-format
msgid "What gets injected"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "The CDI specification defines a procedure, called <emphasis>typesafe resolution</emphasis>, that the container follows when identifying the bean to inject to an injection point. This algorithm looks complex at first, but once you understand it, it&#39;s really quite intuitive. Typesafe resolution is performed at system initialization time, which means that the container will inform the developer immediately if a bean&#39;s dependencies cannot be satisfied."
msgstr "La especificación de Web Beans define un procedimiento, llamado <emphasis>algoritmo de resolución de typesafe</emphasis> que el administrador de Web Bean sigue al identificar el Web Bean para inyectar a un punto de inyección. Este algoritmo parece complejo en un principio, pero una vez que lo entienda, es en realidad muy intuitivo. La resolución de Typesafe se realiza al inicializar el sistema, lo que significa que el administrador informará al usuario inmediatamente si se pueden cumplir las dependencias de un Web Bean, produciendo una <literal>UnsatisfiedDependencyException</literal> o una <literal>AmbiguousDependencyException</literal>."

#. Tag: para
#, fuzzy, no-c-format
msgid "The purpose of this algorithm is to allow multiple beans to implement the same bean type and either:"
msgstr "El propósito de este algoritmo es permitir a múltiples Web Beans implementar el mismo tipo API ya sea:"

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the client to select which implementation it requires using a <emphasis>qualifier</emphasis> or"
msgstr "permitiendo al cliente seleccionar la aplicación requerida mediante <emphasis>anotaciones de enlace</emphasis>,"

#. Tag: para
#, fuzzy, no-c-format
msgid "allow the application deployer to select which implementation is appropriate for a particular deployment, without changes to the client, by enabling or disabling an <emphasis>alternative</emphasis>, or"
msgstr "permitiendo al desplegador de aplicación seleccionar la aplicación apropiada para una despliegue particular, sin cambios en el cliente, habilitando o inhabilitando los <emphasis>tipos de despliegue</emphasis>, o"

#. Tag: para
#, no-c-format
msgid "allow the beans to be isolated into separate modules."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Obviously, if you have exactly one bean of a given type, and an injection point with that same type, then bean A is going to go into slot A. That&#39;s the simplest possible scenario. When you first start your application, you&#39;ll likely have lots of those."
msgstr ""

#. Tag: para
#, no-c-format
msgid "But then, things start to get complicated. Let&#39;s explore how the container determines which bean to inject in more advanced cases. We&#39;ll start by taking a closer look at qualifiers."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Qualifier annotations"
msgstr "Anotaciones de Enlace"

#. Tag: para
#, fuzzy, no-c-format
msgid "If we have more than one bean that implements a particular bean type, the injection point can specify exactly which bean should be injected using a qualifier annotation. For example, there might be two implementations of <literal>PaymentProcessor</literal>:"
msgstr "Si tenemos más de un Web Bean que implemente un tipo determinado de API, el punto de inyección puede especificar el Web Bean que debe ser inyectado mediante una anotación de enlace. Por ejemplo, deberían haber dos aplicaciones del <literal>PaymentProcessor</literal>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> are qualifier annotations:"
msgstr "Donde <literal>@PayByCheque</literal> y <literal>@PayByCreditCard</literal> son anotaciones de enlace:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "A client bean developer uses the qualifier annotation to specify exactly which bean should be injected."
msgstr "Un desarrollador de cliente de Web Bean utiliza la anotación de enlace para especificar exactamente el Web Bean que debe inyectarse."

#. Tag: para
#, no-c-format
msgid "Using field injection:"
msgstr "Uso de inyección de campo:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;"
msgstr ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#, no-c-format
msgid "Using initializer method injection:"
msgstr "Uso de inyección de método inicializador:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Using constructor injection:"
msgstr "O uso de inyección de constructor:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Qualifier annotations can also qualify method arguments of producer, disposer and observer methods. Combining qualified arguments with producer methods is a good way to have an implementation of a bean type selected at runtime based on the state of the system:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "If an injected field or a parameter of a bean constructor or initializer method is not explicitly annotated with a qualifier, the default qualifier, <literal>@Default</literal>, is assumed."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, you may be thinking, <emphasis>&#34;What&#39;s the different between using a qualifier and just specifying the exact implementation class you want?&#34;</emphasis> It&#39;s important to understand that a qualifier is like an extension of the interface. It does not create a direct dependency to any particular implementation. There may be multiple alterative implementations of <literal>@Asynchronous PaymentProcessor</literal>!"
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "The built-in qualifiers <literal>@Default</literal> and <literal>@Any</literal>"
msgstr "Los Web Beans sencillos admiten únicamente las devoluciones de llamadas <literal>@PostConstruct</literal> y <literal>@PreDestroy</literal>."

#. Tag: para
#, no-c-format
msgid "Whenever a bean or injection point does not explicitly declare a qualifier, the container assumes the qualifier <literal>@Default</literal>. From time to time, you&#39;ll need to decare an injection point without specifying a qualifier. There&#39;s a qualifier for that too. All beans have the qualifier <literal>@Any</literal>. Therefore, by explicitly specifying <literal>@Any</literal> at an injection point, you suppress the default qualifier, without otherwise restricting the beans that are eligible for injection."
msgstr ""

#. Tag: para
#, no-c-format
msgid "This is especially useful if you want to iterate over all beans with a certain bean type. For example:"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"@Inject \n"
"void initServices(@Any Instance&#60;Service&#62; services) { \n"
"   for (Service service: services) {\n"
"      service.init();\n"
"   }\n"
"}"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Qualifiers with members"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Java annotations can have members. We can use annotation members to further discriminate a qualifier. This prevents a potential explosion of new annotations. For example, instead of creating several qualifiers representing different payment methods, we could aggregate them into a single annotation with a member:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Then we select one of the possible member values when appling the qualifier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We can force the container to ignore a member of a qualifier type by annotating the member <literal>@Nonbinding</literal>."
msgstr "Se puede pedir al administrador de Web Bean que ignore a un miembro de un tipo de anotación de enlace anotando al miembro <literal>@NonBinding</literal>."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @Nonbinding String comment() default &#34;&#34;;\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Multiple qualifiers"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "An injection point may specify multiple qualifiers:"
msgstr "Un punto de inyección puede incluso especificar múltiples anotaciones de enlace:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Then only a bean which has <emphasis>both</emphasis> qualifier annotations would be eligible for injection."
msgstr "En este caso, sólo el Web Bean que tiene <emphasis>ambas</emphasis> anotaciones de enlace sería elegible para inyección."

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: title
#, no-c-format
msgid "Alternatives"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatives are beans whose implementation is specific to a particular client module or deployment scenario. This alternative defines a mock implementation of both <literal>@Synchronous PaymentProcessor</literal> and <literal>@Asynchronous PaymentProcessor</literal>, all in one:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "By default, <literal>@Alternative</literal> beans are disabled. We need to <emphasis>enable</emphasis> an alternative in the <literal>beans.xml</literal> descriptor of a bean archive to make it available for instantiation and injection. This activation only applies to the beans in that archive."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"&#60;beans\n"
"   xmlns=&#34;http://java.sun.com/xml/ns/javaee&#34;\n"
"   xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;\n"
"   xsi:schemaLocation=&#34;\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd&#34;&#62;\n"
"   &#60;alternatives&#62;\n"
"         &#60;class&#62;org.mycompany.mock.MockPaymentProcessor&#60;/class&#62;\n"
"   &#60;/alternatives&#62;\n"
"&#60;/beans&#62;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "When an ambiguous dependency exists at an injection point, the container attempts to resolve the ambiguity by looking for an enabled alternative among the beans that could be injected. If there is exactly one enabled alternative, that&#39;s the bean that will be injected."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Fixing unsatisfied and ambiguous dependencies"
msgstr "Corregir dependencias insatisfechas"

#. Tag: para
#, fuzzy, no-c-format
msgid "The typesafe resolution algorithm fails when, after considering the qualifier annotations on all beans that implement the bean type of an injection point and filtering out disabled beans (<literal>@Alternative</literal> beans which are not explicitly enabled), the container is unable to identify exactly one bean to inject. The container will abort deployment, informing us of the unsatisfied or ambiguous dependency."
msgstr "El algoritmo de resolución typesafe falla cuando, después de considerar las anotaciones de enlace y los tipos de despliegue de todos los Web Beans que implementan el tipo API de un punto de inyección, el administrador de Web Bean no puede identificar con precisión un Web Bean para inyectar."

#. Tag: para
#, no-c-format
msgid "During the course of your development, you&#39;re going to encounter this situation. Let&#39;s learn how to resolve it."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>unsatisfied dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "create a bean which implements the bean type and has all the qualifier types of the injection point,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "make sure that the bean you already have is in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "explicitly enable an <literal>@Alternative</literal> bean that implements the bean type and has the appropriate qualifier types, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "To fix an <emphasis>ambiguous dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce a qualifier to distinguish between the two implementations of the bean type,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of the beans by annotating it <literal>@Alternative</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "move one of the implementations to a module that is not in the classpath of the module with the injection point, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "disable one of two <literal>@Alternative</literal> beans that are trying to occupy the same space, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "See <ulink url=\"http://sfwk.org/Documentation/HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType\">this FAQ</ulink> for step-by-step instructions for how to resolve an ambigous resolution exception between a raw bean type and a producer method that returns the same bean type."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Just remember: &#34;There can be only one.&#34;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "On the other hand, if you really do have an optional or multivalued injection point, you should change the type of your injection point to <literal>Instance</literal>, as we&#39;ll see in <xref linkend=\"lookup\" />."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Now there&#39;s one more issue you need to be aware of when using the dependency injection service."
msgstr "Hay algo más que necesita saber cuando utilice inyección de dependencia en Web Beans."

#. Tag: title
#, no-c-format
msgid "Client proxies"
msgstr "Los proxy de cliente"

#. Tag: para
#, fuzzy, no-c-format
msgid "Clients of an injected bean do not usually hold a direct reference to a bean instance, unless the bean is a dependent object (scope <literal>@Dependent</literal>)."
msgstr "Los clientes de un Web Bean inyectado no suelen mantener una referencia directa a una instancia de Web Bean."

#. Tag: para
#, fuzzy, no-c-format
msgid "Imagine that a bean bound to the application scope held a direct reference to a bean bound to the request scope. The application-scoped bean is shared between many different requests. However, each request should see a different instance of the request scoped bean—the current one!"
msgstr "Imagine que un Web Bean vinculado al ámbito de aplicación mantiene una referencia directa a un Web Bean vinculado al ámbito de petición. La aplicación en el ámbito de Web Bean es compartida entre muchas peticiones diferentes. No obstante, cada petición ¡debe ver una instancia diferente de la petición en el ámbito de WebBean!"

#. Tag: para
#, fuzzy, no-c-format
msgid "Now imagine that a bean bound to the session scope holds a direct reference to a bean bound to the application scope. From time to time, the session context is serialized to disk in order to use memory more efficiently. However, the application scoped bean instance should not be serialized along with the session scoped bean! It can get that reference any time. No need to hoard it!"
msgstr "Ahora imaginemos que un enlace de Web Bean a la sesión mantiene una referencia directa a un Web Bean enlazado al ámbito de la aplicación. De vez en cuando, el contexto de sesión se serializa al disco con el fin de utilizar la memoria de un modo más eficiente. Sin embargo, la aplicación en el ámbito de la instancia de Web Bean ¡no debe serializarse junto con la sesión en el ámbito de Web Bean!"

#. Tag: para
#, fuzzy, no-c-format
msgid "Therefore, unless a bean has the default scope <literal>@Dependent</literal>, the container must indirect all injected references to the bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible for ensuring that the bean instance that receives a method invocation is the instance that is associated with the current context. The client proxy also allows beans bound to contexts such as the session context to be serialized to disk without recursively serializing other injected beans."
msgstr "Por lo tanto, a menos que un Web Bean tenga un ámbito predeterminado <literal>@Dependent</literal>, el administrador de Web Bean deberá direccionar indirectamente todas las referencias inyectadas al Web Bean a través del objeto de proxy. Este <emphasis>proxy de cliente</emphasis> responsable de garantizar que la instancia de Web Bean reciba un método de invocación es la instancia asociada con el contexto actual. El proxy de cliente también permite a los Web Beans vincularse a contextos tales como el contexto de sesión que debe serializarse al disco sin serializar de modo recursivo a otros Web Beans inyectados."

#. Tag: para
#, fuzzy, no-c-format
msgid "Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the container. If an injection point declared with one of these types resolves to a bean with any scope other than <literal>@Dependent</literal>, the container will abort deployment, informing us of the problem."
msgstr "Lamentablemente, debido a limitaciones del lenguaje de Java, el administrador de Web Bean no puede utilizar proxy en algunos tipos de Java. Por lo tanto, el administrador de Web Bean produce un <literal>UnproxyableDependencyException</literal> si no se puede aplicar proxy al tipo de un punto de inyección."

#. Tag: para
#, fuzzy, no-c-format
msgid "The following Java types cannot be proxied by the container:"
msgstr "El administrador de Web Bean no puede aplicar proxy en los siguientes tipos de Java:"

#. Tag: para
#, fuzzy, no-c-format
msgid "classes which don&#39;t have a non-private constructor with no parameters, and"
msgstr "las clases que no tienen un constructor no-privado sin parámetros y "

#. Tag: para
#, no-c-format
msgid "classes which are declared <literal>final</literal> or have a <literal>final</literal> method,"
msgstr "las clases que son declaradas <literal>final</literal> o tienen un método <literal>final</literal>,"

#. Tag: para
#, no-c-format
msgid "arrays and primitive types."
msgstr "matrices y tipos primarios."

#. Tag: para
#, no-c-format
msgid "It&#39;s usually very easy to fix an unproxyable dependency problem. If an injection point of type <literal>X</literal> results in an unproxyable dependency, simply:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "add a constructor with no parameters to <literal>X</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "change the type of the injection point to <literal>Instance&#60;X&#62;</literal>,"
msgstr ""

#. Tag: para
#, no-c-format
msgid "introduce an interface <literal>Y</literal>, implemented by the injected bean, and change the type of the injection point to <literal>Y</literal>, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "A future release of Weld will likely support a non-standard workaround for this limitation, using non-portable JVM APIs:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most efficient)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "IBM, JRockit: <literal>ReflectionFactory.newConstructorForSerialization()</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "But we didn&#39;t get around to implementing this yet."
msgstr ""

#. Tag: title
#, fuzzy, no-c-format
msgid "Obtaining a contextual instance by programmatic lookup"
msgstr "Obtención de un Web Bean por búsqueda programática"

#. Tag: para
#, no-c-format
msgid "In certain situations, injection is not the most convenient way to obtain a contextual reference. For example, it may not be used when:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "the bean type or qualifiers vary dynamically at runtime, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or"
msgstr ""

#. Tag: para
#, no-c-format
msgid "we would like to iterate over all beans of a certain type."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "In these situations, the application may obtain an instance of the interface <literal>Instance</literal>, parameterized for the bean type, by injection:"
msgstr "La aplicación puede obtener una instancia de la interfaz <literal>Manager</literal> a través de inyección:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "The <literal>get()</literal> method of <literal>Instance</literal> produces a contextual instance of the bean."
msgstr "Tipos de despliegue <literal>@Mock</literal> y <literal>@Staging</literal> para pruebas"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "PaymentProcessor p = paymentProcessorSource.get();"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Qualifiers can be specified in one of two ways:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "by annotating the <literal>Instance</literal> injection point, or"
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "by passing qualifiers to the <literal>select()</literal> of <literal>Event</literal>."
msgstr "Los Web Beans sencillos admiten únicamente las devoluciones de llamadas <literal>@PostConstruct</literal> y <literal>@PreDestroy</literal>."

#. Tag: para
#, no-c-format
msgid "Specifying the qualifiers at the injection point is much, much easier:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Asynchronous Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Now, the <literal>PaymentProcessor</literal> returned by <literal>get()</literal> will have the qualifier <literal>@Asynchronous</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatively, we can specify the qualifier dynamically. First, we add the <literal>@Any</literal> qualifier to the injection point, to suppress the default qualifier. (All beans have the qualifier <literal>@Any</literal>.)"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject @Any Instance&#60;PaymentProcessor&#62; paymentProcessorSource;"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#, no-c-format
msgid "Next, we need to obtain an instance of our qualifier type. Since annotatons are interfaces, we can&#39;t just write <literal>new Asynchronous()</literal>. It&#39;s also quite tedious to create a concrete implementation of an annotation type from scratch. Instead, CDI lets us obtain a qualifier instance by subclassing the helper class <literal>AnnotationLiteral</literal>."
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral&#60;Asynchronous&#62; implements Asynchronous {}"
msgstr ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"

#. Tag: para
#, no-c-format
msgid "In some cases, we can use an anonymous class:"
msgstr ""

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral&#60;Asynchronous&#62;() {});"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new AnnotationLiteral<CreditCard>(){});]]>"

#. Tag: para
#, no-c-format
msgid "We can&#39;t use an anonymous class to implement a qualifier type with members."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Now, finally, we can pass the qualifier to the <literal>select()</literal> method of <literal>Instance</literal>."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid ""
"Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);"
msgstr ""

#. Tag: title
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "El objeto <literal>InjectionPoint</literal>"

#. Tag: para
#, fuzzy, no-c-format
msgid "There are certain kinds of dependent objects (beans with scope <literal>@Dependent</literal>) that need to know something about the object or injection point into which they are injected in order to be able to do what they do. For example:"
msgstr "Hay algunas clases de objetos &#151; con ámbito <literal>@Dependent</literal> &#151; que necesitan saber algo acerca del objeto o punto de inyección dentro del cual son inyectados para poder hacer lo que hacen. Por ejemplo:"

#. Tag: para
#, no-c-format
msgid "The log category for a <literal>Logger</literal> depends upon the class of the object that owns it."
msgstr "La categoría de registro para un <literal>Logger</literal> depende de la clase de objeto que lo posea."

#. Tag: para
#, no-c-format
msgid "Injection of a HTTP parameter or header value depends upon what parameter or header name was specified at the injection point."
msgstr "La inyección de un parámetro HTTP o valor de encabezado depende del parámetro o del nombre de encabezado especificado en el punto de inyección."

#. Tag: para
#, no-c-format
msgid "Injection of the result of an EL expression evaluation depends upon the expression that was specified at the injection point."
msgstr "La inyección del resultado de una prueba de expresión EL depende de la expresión que fue especificada en el punto de inyección."

#. Tag: para
#, fuzzy, no-c-format
msgid "A bean with scope <literal>@Dependent</literal> may inject an instance of <literal>InjectionPoint</literal> and access metadata relating to the injection point to which it belongs."
msgstr "Un Web Bean con ámbito <literal>@Dependent</literal> puede inyectar una instancia de <literal>InjectionPoint</literal> y acceder a metadatos relativos al punto de inyección al que pertenezca."

#. Tag: para
#, fuzzy, no-c-format
msgid "Let&#39;s look at an example. The following code is verbose, and vulnerable to refactoring problems:"
msgstr "Veamos un ejemplo. El código siguiente es detallado, y vulnerable a problemas de refactorización:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "Logger log = Logger.getLogger(MyClass.class.getName());"
msgstr "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"

#. Tag: para
#, no-c-format
msgid "This clever little producer method lets you inject a JDK <literal>Logger</literal> without explicitly specifying the log category:"
msgstr "Este método inteligente de productor permite inyectar un <literal>Logger</literal> JDK sin especificar explícitamente la categoría de registro:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "We can now write:"
msgstr "Ahora podemos escribir:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid "@Inject Logger log;"
msgstr "<![CDATA[@Current Logger log;]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "Not convinced? Then here&#39;s a second example. To inject HTTP parameters, we need to define a qualifier type:"
msgstr "¿No está convencido? Entonces, veamos un segundo ejemplo. Para inyectar parámetros, necesitamos definir el tipo de vinculación:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @Nonbinding public String value();\n"
"}"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: para
#, fuzzy, no-c-format
msgid "We would use this qualifier type at injection points as follows:"
msgstr "Utilizaríamos este tipo de enlace en puntos de inyección, como a continuación:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"@HttpParam(&#34;username&#34;) String username;\n"
"@HttpParam(&#34;password&#34;) String password;"
msgstr ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"

#. Tag: para
#, no-c-format
msgid "The following producer method does the work:"
msgstr "El siguiente método de productor sí funciona:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"class HttpParams\n"
"\n"
"   @Produces @HttpParam(&#34;&#34;)\n"
"   String getParamValue(InjectionPoint ip) {\n"
"      ServletRequest request = (ServletRequest) FacesContext.getCurrentInstance().getExternalContext().getRequest();\n"
"      return request.getParameter(ip.getAnnotated().getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}"
msgstr ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#, no-c-format
msgid "Note that acquiring of the request in this example is JSF-centric. For a more generic solution you could write your own prodcuer for the request and have it injected as a method parameter."
msgstr ""

#. Tag: para
#, fuzzy, no-c-format
msgid "Note also that the <literal>value()</literal> member of the <literal>HttpParam</literal> annotation is ignored by the container since it is annotated <literal>@Nonbinding.</literal>"
msgstr "(Observe que el miembro del <literal>valor()</literal> de la anotación <literal>HttpParam</literal> es ignorado por el administrador de Web Bean porque está anotado como <literal>@NonBinding.</literal>)"

#. Tag: para
#, fuzzy, no-c-format
msgid "The container provides a built-in bean that implements the <literal>InjectionPoint</literal> interface:"
msgstr "El administrador de Web Bean proporciona un Web Bean incorporado que implementa la interfaz <literal>InjectionPoint</literal>:"

#. Tag: programlisting
#, fuzzy, no-c-format
msgid ""
"public interface InjectionPoint { \n"
"   public Type getType();\n"
"   public Set&#60;Annotation&#62; getQualifiers();\n"
"   public Bean&#60;?&#62; getBean();\n"
"   public Member getMember();\n"
"   public Annotated getAnnotated();\n"
"   public boolean isDelegate();\n"
"   public boolean isTransient();\n"
"}"
msgstr ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"

#, fuzzy
#~ msgid "It's usually very easy to fix an unproxyable dependency problem. Simply add a constructor with no parameters to the injected class, introduce an interface, or, if all else fails, change the scope of the injected bean to <literal>@Dependent</literal>."
#~ msgstr "Suele ser muy fácil corregir una <literal>UnproxyableDependencyException</literal>. Basta con añadir un constructor sin parámetros a la clase inyectada, introducir una interfaz, o cambiar el ámbito del Web Bean inyectado a <literal>@Dependent</literal>."

#~ msgid "Web Beans supports three primary mechanisms for dependency injection:"
#~ msgstr "Web Beans soporta tres mecanismos primarios para inyección de dependencia:"

#~ msgid "Constructor parameter injection:"
#~ msgstr "Constructor de inyección de parámetro:"

#~ msgid "Constructor parameter injection is not supported for EJB beans, since the EJB is instantiated by the EJB container, not the Web Bean manager."
#~ msgstr "La inyección de parámetro constructor no es admitida por beans de EJB, porque EJB es instanciado por el contenedor de EJB, no por el administrador de Web Bean."

#~ msgid "Parameters of constructors and initializer methods need not be explicitly annotated when the default binding type <literal>@Current</literal> applies. Injected fields, however, <emphasis>must</emphasis> specify a binding type, even when the default binding type applies. If the field does not specify a binding type, it will not be injected."
#~ msgstr "Los parámetros de constructores y métodos de inicializador no necesitan ser anotados explícitamente cuando se aplique el tipo de enlace predeterminado <literal>@Current</literal>. Los campos inyectados, sin embargo, <emphasis>deben</emphasis> especificar un tipo de enlace, cuando se aplique el tipo de enlace predeterminado. Si el campo no especifica ningún tipo de enlace, no será inyectado."

#~ msgid "Producer methods also support parameter injection:"
#~ msgstr "Los métodos de productor también admiten inyección de parámetro:"

#~ msgid "Finally, observer methods (which we'll meet in <xref linkend=\"events\"/>), disposal methods and destructor methods all support parameter injection."
#~ msgstr "Por último, los métodos de observador (que encontraremos en <xref linkend=\"events\"/>), los métodos desechables y los métodos destructores, admiten inyección de parámetro."

#~ msgid "allow one implementation of an API to override another implementation of the same API at deployment time, without changes to the client, using <emphasis>deployment type precedence</emphasis>."
#~ msgstr "permitiendo que una implementación de una API remplace otra implementación de la misma API en el momento del despliegue, sin cambios al cliente, mediante <emphasis>prioridad de tipo de despliegue</emphasis>."

#~ msgid "Let's explore how the Web Beans manager determines a Web Bean to be injected."
#~ msgstr "Exploremos cómo el administrador de Web Beans determina una Web Bean para ser inyectado."

#~ msgid ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"

#~ msgid "Binding annotations with members"
#~ msgstr "Anotaciones de enlace con miembros"

#~ msgid "Binding annotations may have members:"
#~ msgstr "Las anotaciones de enlace pueden tener miembros:"

#~ msgid "In which case, the member value is significant:"
#~ msgstr "En cuyo caso, el valor de miembro es importante:"

#~ msgid ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"
#~ msgstr ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"

#~ msgid "Combinations of binding annnotations"
#~ msgstr "Combinaciones de anotaciones de enlace"

#~ msgid "Binding annotations and producer methods"
#~ msgstr "Anotaciones de enlace y métodos de productor"

#~ msgid "Even producer methods may specify binding annotations:"
#~ msgstr "Incluso los métodos de productor pueden especificar anotaciones de enlace:"

#~ msgid ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"

#~ msgid "The default binding type"
#~ msgstr "El tipo de enlace predeterminado"

#~ msgid "Web Beans defines a binding type <literal>@Current</literal> that is the default binding type for any injection point or Web Bean that does not explicitly specify a binding type."
#~ msgstr "Web Beans define un tipo de enlace <literal>@Current</literal>, el cual es el tipo de enlace predeterminado para cualquier punto de inyección o Web Bean que no especifique explícitamente un tipo de enlace."

#~ msgid "There are two common circumstances in which it is necessary to explicitly specify <literal>@Current</literal>:"
#~ msgstr "Hay dos circunstancias comunes en que se necesita especificar explícitamente a <literal>@Current</literal>:"

#~ msgid "on a field, in order to declare it as an injected field with the default binding type, and"
#~ msgstr "en un campo, para declararlo como un campo inyectado con el tipo de enlace por defecto, y "

#~ msgid "on a Web Bean which has another binding type in addition to the default binding type."
#~ msgstr "en un Web Bean, el cual tiene otro tipo de enlace además del tipo de enlace predeterminado."

#~ msgid "Deployment types"
#~ msgstr "Tipos de despliegue"

#~ msgid "All Web Beans have a <emphasis>deployment type</emphasis>. Each deployment type identifies a set of Web Beans that should be conditionally installed in some deployments of the system."
#~ msgstr "Todos los Web Beans tienen un <emphasis>tipo de despliegue</emphasis>. Cada tipo de despliegue identifica un conjunto de Web Beans que debería ser instalado bajo condiciones en algunos despliegues del sistema."

#~ msgid "For example, we could define a deployment type named <literal>@Mock</literal>, which would identify Web Beans that should only be installed when the system executes inside an integration testing environment:"
#~ msgstr "Por ejemplo, podríamos definir un tipo de despliegue llamado <literal>@Mock</literal>, el cual identificaría Web Beans que deben ser instalados sólo cuando el sistema se ejecute dentro de un entorno de pruebas de integración:"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"

#~ msgid "Suppose we had some Web Bean that interacted with an external system to process payments:"
#~ msgstr "Supongamos que tenemos algunos Web Bean que interactuaron con un sistema externo para procesar pagos:"

#~ msgid ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#~ msgid "Since this Web Bean does not explicitly specify a deployment type, it has the default deployment type <literal>@Production</literal>."
#~ msgstr "Como este Web Bean no especifica explícitamente un tipo de despliegue, tiene el tipo de despliegue predeterminado <literal>@Production</literal>."

#~ msgid "For integration or unit testing, the external system is slow or unavailable. So we would create a mock object:"
#~ msgstr "Para prueba de integración o de unidad, el sistema externo está lento o no está disponible. Por lo tanto, creamos el objeto mock:"

#~ msgid ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "But how does the Web Bean manager determine which implementation to use in a particular deployment?"
#~ msgstr "Pero, ¿cómo determina el administrador de Web Bean la aplicación que debe utilizar en un despliegue determinado?"

#~ msgid "Enabling deployment types"
#~ msgstr "Habilitar tipos de despliegue"

#~ msgid "Web Beans defines two built-in deployment types: <literal>@Production</literal> and <literal>@Standard</literal>. By default, only Web Beans with the built-in deployment types are enabled when the system is deployed. We can identify additional deployment types to be enabled in a particular deployment by listing them in <literal>web-beans.xml</literal>."
#~ msgstr "Web Beans define dos tipos de despliegue incorporados: <literal>@Production</literal> y <literal>@Standard</literal>. Por defecto, sólo los Web Beans con tipos de despliegue incorporados se habilitan cuando se despliega el sistema. Podemos identificar tipos de despliegue adicionales en un despliegue particular listándolos en <literal>web-beans.xml</literal>."

#~ msgid "Going back to our example, when we deploy our integration tests, we want all our <literal>@Mock</literal> objects to be installed:"
#~ msgstr "Volviendo a nuestro ejemplo, cuando desplegamos nuestras pruebas de integración, deseamos que todos nuestros objetos <literal>@Mock</literal> sean instalados:"

#~ msgid ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"
#~ msgstr ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"

#~ msgid "Now the Web Bean manager will identify and install all Web Beans annotated <literal>@Production</literal>, <literal>@Standard</literal> or <literal>@Mock</literal> at deployment time."
#~ msgstr "Ahora el administrador de Web Bean identificará e instalará todos los Web Beans anotados <literal>@Production</literal>, <literal>@Standard</literal> o <literal>@Mock</literal> en el momento del despliegue."

#~ msgid "The deployment type <literal>@Standard</literal> is used only for certain special Web Beans defined by the Web Beans specification. We can't use it for our own Web Beans, and we can't disable it."
#~ msgstr "El tipo de despliegue <literal>@Standard</literal> es utilizado únicamente por algunos Web Beans especiales definidos por la especificación de Web Beans. No podemos utilizarlo para nuestros propios Web Beans ni inhabilitarlo."

#~ msgid "The deployment type <literal>@Production</literal> is the default deployment type for Web Beans which don't explicitly declare a deployment type, and may be disabled."
#~ msgstr "El tipo de despliegue <literal>@Production</literal> es el tipo de despliegue predeterminado para Web Beans que no declaran explícitamente un tipo de despliegue, y que se puede inhabilitar."

#~ msgid "Deployment type precedence"
#~ msgstr "Prioridad de tipo de despliegue"

#~ msgid "If you've been paying attention, you're probably wondering how the Web Bean manager decides which implementation &#151; <literal>ExternalPaymentProcessor</literal> or <literal>MockPaymentProcessor</literal> &#151; to choose. Consider what happens when the manager encounters this injection point:"
#~ msgstr "Si ha prestado atención, probablemente se estará preguntando cómo escoge Web Bean la aplicación &#151; <literal>ExternalPaymentProcessor</literal> o <literal>MockPaymentProcessor</literal> &#151; . Piense en lo que sucede cuando el administrador encuentra este punto de inyección:"

#~ msgid "There are now two Web Beans which satisfy the <literal>PaymentProcessor</literal> contract. Of course, we can't use a binding annotation to disambiguate, since binding annotations are hard-coded into the source at the injection point, and we want the manager to be able to decide at deployment time!"
#~ msgstr "Ahora hay dos Web Beans que cumplen el contrato <literal>PaymentProcessor</literal>. Claro está que no podemos utilizar una anotación de enlace para explicar, porque las anotaciones de enlace están codificadas dentro de la fuente en el punto de inyección, y queremos que el administrador pueda decidir en el ¡momento de despliegue!"

#~ msgid "The solution to this problem is that each deployment type has a different <emphasis>precedence</emphasis>. The precedence of the deployment types is determined by the order in which they appear in <literal>web-beans.xml</literal>. In our example, <literal>@Mock</literal> appears later than <literal>@Production</literal> so it has a higher precedence."
#~ msgstr "La solución a este problema es que cada tipo de despliegue tiene una <emphasis>prioridad</emphasis> diferente. La prioridad de los tipos de despliegue es determinada por el orden de aparición en <literal>web-beans.xml</literal>. En nuestro ejemplo, <literal>@Mock</literal> es posterior a <literal>@Production</literal> por lo tanto tiene mayor prioridad."

#~ msgid "Whenever the manager discovers that more than one Web Bean could satisfy the contract (API type plus binding annotations) specified by an injection point, it considers the relative precedence of the Web Beans. If one has a higher precedence than the others, it chooses the higher precedence Web Bean to inject. So, in our example, the Web Bean manager will inject <literal>MockPaymentProcessor</literal> when executing in our integration testing environment (which is exactly what we want)."
#~ msgstr "Cada vez que el administrador descubre que más de un Web Bean cumple el contrato (tipo API más anotaciones de enlace) especificado por un punto de inyección, considera la prioridad relativa de los Web Beans. Se escoge el Web Bean que tiene prioridad respecto de los otros para inyectar. Por lo tanto, en nuestro ejemplo, el administrador de Web Bean inyectará <literal>MockPaymentProcessor</literal> al ejecutar en nuestro entorno de prueba de integración (que es precisamente lo que queremos)."

#~ msgid "It's interesting to compare this facility to today's popular manager architectures. Various \"lightweight\" containers also allow conditional deployment of classes that exist in the classpath, but the classes that are to be deployed must be explicity, individually, listed in configuration code or in some XML configuration file. Web Beans does support Web Bean definition and configuration via XML, but in the common case where no complex configuration is required, deployment types allow a whole set of Web Beans to be enabled with a single line of XML. Meanwhile, a developer browsing the code can easily identify what deployment scenarios the Web Bean will be used in."
#~ msgstr "Es interesante comparar esta facilidad con las arquitecturas populares del administrador de hoy. Varios contenedores \"ligeros\" también permiten el despliegue condicional de clases existentes en el classpath, pero las clases que van a ser desplegadas deben ser explícitamente, listadas de modo individual en el código de configuración o en algún archivo de configuración XML. Web Beans no admite definición de Web Bean ni configuración vía XML, pero en el común de los casos donde no se requiere una configuración compleja, los tipos de despliegue permiten habilitar un conjunto completo de Web Beans con una sóla línea de XML. Mientras tanto, un desarrollador que esté navegando el código puede fácilmente identificar en qué escenarios de despliegue se utilizará el Web Bean."

#~ msgid "Example deployment types"
#~ msgstr "Ejemplo de tipos de despliegue"

#~ msgid "Deployment types are useful for all kinds of things, here's some examples:"
#~ msgstr "Los tipos de despliegue son útiles para toda clase de cosas, algunos ejemplos a continuación:"

#~ msgid "<literal>@AustralianTaxLaw</literal> for site-specific Web Beans"
#~ msgstr "<literal>@AustralianTaxLaw</literal> para Web Beans de sitio específico"

#~ msgid "<literal>@SeamFramework</literal>, <literal>@Guice</literal> for third-party frameworks which build on Web Beans"
#~ msgstr "<literal>@SeamFramework</literal>, <literal>@Guice</literal> para marcos de terceras partes generados en Web Beans"

#~ msgid "<literal>@Standard</literal> for standard Web Beans defined by the Web Beans specification"
#~ msgstr "<literal>@Standard</literal>para Web Beans estándar definidos por la especificación Web Beans"

#~ msgid "I'm sure you can think of more applications..."
#~ msgstr "Estamos seguros que puede pensar en más aplicaciones..."

#~ msgid "It's usually easy to fix an <literal>UnsatisfiedDependencyException</literal> or <literal>AmbiguousDependencyException</literal>."
#~ msgstr "Por lo general es fácil corregir una <literal>UnsatisfiedDependencyException</literal> o una <literal>AmbiguousDependencyException</literal>."

#~ msgid "To fix an <literal>UnsatisfiedDependencyException</literal>, simply provide a Web Bean which implements the API type and has the binding types of the injection point &#151; or enable the deployment type of a Web Bean that already implements the API type and has the binding types."
#~ msgstr "Para corregir una <literal>UnsatisfiedDependencyException</literal>, basta con proporcionar un Web Bean que implemente el tipo API y tenga los tipos de enlace del punto de inyección &#151; o permita el tipo de despliegue de un Web Bean que ya implemente el tipo API y tenga los tipos de enlace."

#~ msgid "To fix an <literal>AmbiguousDependencyException</literal>, introduce a binding type to distinguish between the two implementations of the API type, or change the deployment type of one of the implementations so that the Web Bean manager can use deployment type precedence to choose between them. An <literal>AmbiguousDependencyException</literal> can only occur if two Web Beans share a binding type and have exactly the same deployment type."
#~ msgstr "Para corregir una <literal>AmbiguousDependencyException</literal>, introduzca un tipo de enlace para distinguir entre las dos implementaciones del tipo de API o cambie el tipo de despliegue de una de las implementaciones con el fin de que el administrador de Web Bean pueda utilizar la prioridad de tipo de despliegue para escoger entre ellas. Una <literal>AmbiguousDependencyException</literal> sólo puede presentarse si dos Web Beans comparten un tipo de enlace y tienen exactamente el mismo tipo de despliegue."

#~ msgid "<![CDATA[@Current Manager manager;]]>"
#~ msgstr "<![CDATA[@Current Manager manager;]]>"

#~ msgid "The <literal>Manager</literal> object provides a set of methods for obtaining a Web Bean instance programatically."
#~ msgstr "El objeto <literal>Manager</literal> proporciona un grupo de métodos para obtener una instancia de Web Bean en forma programática."

#~ msgid "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"
#~ msgstr "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"

#~ msgid "Binding annotations may be specified by subclassing the helper class <literal>AnnotationLiteral</literal>, since it is otherwise difficult to instantiate an annotation type in Java."
#~ msgstr "Las anotaciones de enlace se pueden especificar a través de subclasificaciones de la clase auxiliar <literal>AnnotationLiteral</literal>, porque de otra manera es difícil instanciar un tipo de anotación en Java."

#~ msgid "If the binding type has an annotation member, we can't use an anonymous subclass of <literal>AnnotationLiteral</literal> &#151; instead we'll need to create a named subclass:"
#~ msgstr "Si el tipo de vinculación tiene un miembro de anotación, no podemos utilizar una subclase anónima de <literal>AnnotationLiteral</literal> &#151; en su lugar, necesitaremos crear una subclase llamada:"

#~ msgid ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"
#~ msgstr ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
#~ "                                               new CreditCardBinding() { \n"
#~ "                                                   public void value() { return paymentType; } \n"
#~ "                                               } );]]>"

#~ msgid "Lifecycle callbacks, <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal>"
#~ msgstr "El ciclo de vida de los callbacks, <literal>@Resource</literal>, <literal>@EJB</literal> y <literal>@PersistenceContext</literal>"

#~ msgid "Enterprise Web Beans support all the lifecycle callbacks defined by the EJB specification: <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>."
#~ msgstr "Los Web Beans de empresa admiten todos los ciclos de vida de las devoluciones de llamadas definidas por la especificación EJB: <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, <literal>@PrePassivate</literal> y <literal>@PostActivate</literal>."

#~ msgid "Both enterprise and simple Web Beans support the use of <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal> for injection of Java EE resources, EJBs and JPA persistence contexts, respectively. Simple Web Beans do not support the use of <literal>@PersistenceContext(type=EXTENDED)</literal>."
#~ msgstr "Web Beans sencillos y empresariales soportan el uso de <literal>@Resource</literal>, <literal>@EJB</literal> y <literal>@PersistenceContext</literal> para inyección de recursos de Java EE, EJB y contextos de persistencia JPA, respectivamente. Web Beans sencillos no admiten el uso de <literal>@PersistenceContext(type=EXTENDED)</literal>."

#~ msgid "The <literal>@PostConstruct</literal> callback always occurs after all dependencies have been injected."
#~ msgstr "La devolución de llamada <literal>@PostConstruct</literal> siempre se presenta tras la inyección de todas las dependencias."
